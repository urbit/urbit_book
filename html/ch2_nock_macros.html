<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link href="stylesheets/pygments.css" media="screen" rel="stylesheet" type="text/css" />
    <link href="stylesheets/softcover.css" media="screen" rel="stylesheet" type="text/css" />
    <link href="stylesheets/custom.css" media="screen" rel="stylesheet" type="text/css" />
    
    <title>urbit_tutorial</title>
    
      <script type="text/x-mathjax-config">
              MathJax.Hub.Config({
        "HTML-CSS": {
          availableFonts: ["TeX"],
        },
        TeX: {
          extensions: ["AMSmath.js", "AMSsymbols.js"],
          equationNumbers: {
            autoNumber: "AMS",
            formatNumber: function (n) { return "4" + '.' + n }
          },
          Macros: {
            PolyTeX:    "Poly{\\TeX}",
            PolyTeXnic: "Poly{\\TeX}nic",
            sig: "\\textasciitilde",
ket: "\\verb+^+",
phep: "\\kode{-{}-}"
          }
        },
        showProcessingMessages: false,
        messageStyle: "none",
        imageFont: null
      });

      </script>
      <script type="text/javascript" src="MathJax/MathJax.js?config=TeX-AMS-MML_SVG"></script>
    
  </head>
  <body>
    
    <div id="book">
      <div id="cid10" data-tralics-id="cid10" class="chapter" data-number="4" data-chapter="ch2_nock_macros"><h1><a href="ch2_nock_macros_fragment.html#cid10" class="heading hyperref"><span class="number">Chapter 4 </span>Nock Macros</a></h1>
<blockquote class="quotation"><p class="noindent"><em>You get used to it.<span class="intersentencespace"></span> I don’t even see the code.<span class="intersentencespace"></span> All I see is blonde, brunette, redhead.</em></p>
<p style="margin-top: 6.0pt"><span class="break"></span>
—<strong>The Matrix</strong></p>
</blockquote><p>In the last chapter we showed you the Nock specification with lines 32 through 37 removed.<span class="intersentencespace"></span> This chapter will explain what these lines are and what they do:</p>
<div class="code"><div class="highlight"><pre>32 ::    *[a 6 b c d]     *[a 2 [0 1] 2 [1 c d] [1 0] 2 [1 2 3] [1 0] 4 4 b]
33 ::    *[a 7 b c]       *[a 2 b 1 c]
34 ::    *[a 8 b c]       *[a 7 [[7 [0 1] b] 0 1] c]
35 ::    *[a 9 b c]       *[a 7 c 2 [0 1] 0 b]
36 ::    *[a 10 [b c] d]  *[a 8 c 7 [0 3] d]
37 ::    *[a 10 b c]      *[a c]
</pre></div></div>
<p>These lines describe the Nock operators 6 through 10, which are just macros that reduce to operators 0 through 5.<span class="intersentencespace"></span> As you can see, these operators are defined in terms of Nock operators covered in the last chapter.</p>
<p>They add no new functionality to Nock, but we include them in the specification because they are essential to making Nock a practical basis for computation.</p>
</div>
<div id="cid11" data-tralics-id="cid11" class="section" data-number="4.1"><h2><a href="ch2_nock_macros_fragment.html#cid11" class="heading hyperref"><span class="number">4.1 </span>Nock 7</a></h2>
<p>We’ll start with the easiest macro: Nock 7</p>
<div class="code"><div class="highlight"><pre>33 ::    *[a 7 b c]       *[a 2 b 1 c]
</pre></div></div>
<p>We actually already used Nock 7 in the last chapter while we were explaining Nock 2.</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 43] [2 [4 0 3] 1 [3 0 1]])
1
</pre></div></div>
<p>Which sequentially applies the formulas <code>[4 0 3]</code> and <code>[3 0 1]</code> to our subject <code>[42 43]</code>.<span class="intersentencespace"></span> We use Nock 7 whenever we evaluate two formulas on our subject in series.<span class="intersentencespace"></span> The Nock 1 operator in <code>*[a 2 b 1 c]</code> is, as we know, the constant operator, which means that when Nock 2 applies, as in the above example, ‘[1 [3 0 1]]‘ to the subject, [3 0 1] is produced.</p>
<p>Let’s work through a full reduction of the above example, refer to the specification at the end of the last chapter to get a better sense of where these rules are coming from.<span class="intersentencespace"></span> And as always, please copy along on pen and paper or in a text file.</p>
<div class="code"><div class="highlight"><pre>*[[42 43] [2 [4 0 3] 1 [3 0 1]]]

      27 ::    *[a 2 b c]       *[*[a b] *[a c]]


*[*[[42 43] [4 0 3]] *[[42 43] 1 [3 0 1]]]

      26 ::    *[a 1 b]         b


*[*[[42 43] [4 0 3]] [3 0 1]]

      29 ::    *[a 4 b]         +*[a b]

*[+*[[42 43] 0 3] [3 0 1]]

      25 ::    *[a 0 b]         /[b a]

*[+/[3 [42 43]] [3 0 1]]

      18 ::    /[3 a b]         b

*[+43 [3 0 1]]

      11 ::    +a               1 + a

*[44 [3 0 1]]

      28 ::    *[a 3 b]         ?*[a b]

?*[44 0 1]

      25 ::    *[a 0 b]         /[b a]

?/[1 44]

      16 ::    /[1 a]           a

?44

      9  ::    ?a               1
1
</pre></div></div>
<p>This reduction is overly long because we’ve included the full reduction sequences for the Nock 0, 3 and 4 operators, which can usually be omitted without loss of clarity.<span class="intersentencespace"></span> The notation is often helpful, but must be balanced against the needs of conciseness.</p>
<p>Like so:</p>
<div class="code"><div class="highlight"><pre>*[[42 43] [2 [4 0 3] 1 [3 0 1]]]

    27 ::    *[a 2 b c]       *[*[a b] *[a c]]


*[*[[42 43] [4 0 3]] *[[42 43] 1 [3 0 1]]]

    26 ::    *[a 1 b]         b

*[*[[42 43] [4 0 3]] [3 0 1]]

    29 ::    *[a 4 b]         +*[a b]

*[44 [3 0 1]]

    28 ::    *[a 3 b]         ?*[a b]
1
</pre></div></div>
<p>The student of Nock should be able to fill in the missing steps in their minds.</p>
<p>Informally, the formula <code>[7 b c]</code> composes the formulas <code>b</code> and
<code>c</code>.<span class="intersentencespace"></span> To use a bit of math notation, if <code>d</code> is <code>[7 b c]</code>,</p>
<div class="code"><div class="highlight"><pre>d(a) == c(b(a))
</pre></div></div>
<p>Let’s see how this works by applying some reductions to the
definition of <code>7</code>, and producing a simpler definition that
doesn’t look like a macro:</p>
<p><strong><code>7</code> Reduction:</strong></p>
<div class="code"><div class="highlight"><pre>29 ::    *[a 7 b c]        *[a 2 b 1 c]

*[a 2 b 1 c]

23 ::    *[a 2 b c]        *[*[a b] *[a c]] 

*[*[a b] *[a 1 c]]

22:    *[a 1 b]          b
 
*[*[a b] c]
</pre></div></div>
<p><strong><code>7</code> Reduced:</strong></p>
<div class="code"><div class="highlight"><pre>7r ::     *[a 7 b c]         *[*[a b] c]
</pre></div></div>
<p>We’ll skip the full reduction process for the rest of these macros and simply use the reduced forms to explain their function.<span class="intersentencespace"></span> Skip to the Nock reference guidechapter 4 if you want to see the full reduction sequence.</p>
</div>
<div id="cid12" data-tralics-id="cid12" class="section" data-number="4.2"><h2><a href="ch2_nock_macros_fragment.html#cid12" class="heading hyperref"><span class="number">4.2 </span>Nock 8</a></h2>
<div class="code"><div class="highlight"><pre>34 ::    *[a 8 b c]       *[a 7 [[7 [0 1] b] 0 1] c]

34r ::    *[a 8 b c]       *[[*[a b] a] c]
</pre></div></div>
<p>Nock 8 evaluates the formula <code>c</code> with the cell of <code>*[a b]</code> and the original
subject <code>a</code>.<span class="intersentencespace"></span> In other words, in math notation, if <code>d</code> is <code>[8 b c]</code>,</p>
<div class="code"><div class="highlight"><pre>d(a) == c([b(a) a])
</pre></div></div>
<p>But why?<span class="intersentencespace"></span> Suppose, for the purposes of <code>c</code>, we need not just <code>a</code>,
but some intermediate noun computed from <code>a</code> that will be useful
in <code>c</code>’s calculation.<span class="intersentencespace"></span> We apply <code>c</code> with a new subject that’s a
cell of the intermediate value and the old subject - not at all
unlike pushing a new variable on the stack.</p>
<p>Let’s work through some examples:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(42 [8 [4 0 1] [0 1]])
[43 42]

~tomsyt-balsen/try=&gt; .*([42 45] [8 [[4 0 2] [4 0 3]] [0 1]])
[[43 46] 42 45]
</pre></div></div>
<p>For extra credit, a good question to ask yourself: In line 34,</p>
<div class="code"><div class="highlight"><pre>    34 ::    *[a 8 b c]       *[a 7 [[7 [0 1] b] 0 1] c]
</pre></div></div>
<p>why do we need to write <code>[7 [0 1] b]</code> and not just <code>b</code>?</p>
</div>
<div id="cid13" data-tralics-id="cid13" class="section" data-number="4.3"><h2><a href="ch2_nock_macros_fragment.html#cid13" class="heading hyperref"><span class="number">4.3 </span>Nock 6</a></h2>
<div class="code"><div class="highlight"><pre>32 ::    *[a 6 b c d]     *[a 2 [0 1] 2 [1 c d] [1 0] 2 [1 2 3] [1 0] 4 4 b]

32r ::    *[a 6 b c d]     *[a *[[c d] [0 *[[2 3] [0 ++*[a b]]]]]]
</pre></div></div>
<p>Actually, <code>6</code> is a primitive known to every programmer - good old
“if.”<span class="intersentencespace"></span> If <code>b</code> evaluates to <code>0</code>, we produce <code>c</code>; if <code>b</code> evaluates
to <code>1</code>, we produce <code>d</code>; otherwise, we crash.</p>
<p>For instance:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(42 [6 [1 0] [4 0 1] [1 233]])
43
</pre></div></div>
<p>and</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(42 [6 [1 1] [4 0 1] [1 233]])
233
</pre></div></div>
<p>We can actually simplify the semantics of <code>6</code>, at the expense of
breaking the system a little, by creating a macro that works as
“if” only if <code>b</code> is a proper boolean and produces <code>0</code> or <code>1</code>.</p>
<p>This simpler “if” would be:</p>
<div class="code"><div class="highlight"><pre>32s::    *[a 6 b c d]    *[a 2 [0 1] 2 [1 c d] [1 0] [4 4 b]]
</pre></div></div>
<p>This reduces to</p>
<div class="code"><div class="highlight"><pre>32sr::   *[a 6 b c d]     *[a *[[c d] [0 ++*[a b]]]]
</pre></div></div>
<p>Let’s describe what each of <code>a</code>, <code>b</code>, <code>c</code> and <code>d</code> are.</p>
<p><code>a</code> is our subject, some data that we want to run our <code>if</code> on</p>
<p><code>b</code> is our test formula, which returns a <code>yes</code> or a <code>no</code> when we apply it to our subject.</p>
<p><code>c</code> is our <code>then</code> formula, which we want to apply to our subject if our test formula produces a <code>yes</code>, i.e.<span class="intersentencespace"></span> a 0.</p>
<p><code>d</code> is our <code>else</code> formula, which we want to apply to our subject if our test formula produces a <code>no</code>, i.e.<span class="intersentencespace"></span> a 1.</p>
<p>Let’s say we have the following Nock expression:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(42 [6 [3 0 1] [4 0 2] [4 0 1]])
43
</pre></div></div>
<p>Our <code>test</code> is the formula [3 0 1], which tests if the subject is a cell.</p>
<p>Our <code>then</code> is the formula [4 0 2], which increments the head of a cell.</p>
<p>Our <code>else</code> is the formula [4 0 1], which increments an atom.</p>
<p>If we changed our subject to a cell:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([40 43] [6 [3 0 1] [4 0 2] [4 0 1]])
41
</pre></div></div>
<p>With our simpler reduced if rule:</p>
<div class="code"><div class="highlight"><pre>32sr::   *[a 6 b c d]     *[a *[[c d] [0 ++*[a b]]]]
</pre></div></div>
<p>we could rewrite</p>
<div class="code"><div class="highlight"><pre>*[42 [6 [3 0 1] [4 0 2] [4 0 1]]]
</pre></div></div>
<p>as</p>
<div class="code"><div class="highlight"><pre>*[42  *[[[4 0 2] [4 0 1]] [0 ++*[42 [3 0 1]]]]]
</pre></div></div>
<p>Since <code>*[42 [3 0 1]]</code> produces a <code>no</code>, i.e a <code>1</code>:</p>
<div class="code"><div class="highlight"><pre>*[42  *[[[4 0 2] [4 0 1]] [0 ++1]]]]
</pre></div></div>
<p>which gets incremented twice
</p><div class="code"><div class="highlight"><pre>*[42  *[[[4 0 2] [4 0 1]] [0 3]]]
</pre></div></div>
<p>and goes into a Nock 0 to select the tail of <code>[[4 0 2] [4 0 1]]</code></p>
<div class="code"><div class="highlight"><pre>*[42 [4 0 1]]
</pre></div></div>
<p>which increments 42 to produce 43.<span class="intersentencespace"></span> You should be able to see how changing the subject to the cell <code>[40 43]</code> would cause a <code>0</code> to be produced by the test, and how that would cascade into the <code>then</code> formula <code>[4 0 2]</code> being selected and applied instead.</p>
<p>Our real <code>if</code> is only slightly more complicated:</p>
<div class="code"><div class="highlight"><pre>32r ::    *[a 6 b c d]     *[a *[[c d] [0 *[[2 3] [0 ++*[a b]]]]]]
</pre></div></div>
<p>There appears to be an extra step here, using Nock 0 twice, first to select from the cell [2 3], and then to select from the cell [c d].</p>
<p>The reason is fairly simple, if we just used the simpler version of <code>if</code>, tests that returned values other than 0 or 1 would have unexpected behaviour.<span class="intersentencespace"></span> If our our test produced a <code>3</code> we would then try to reference the axis /5 in our cell [c d].<span class="intersentencespace"></span> Since the tail of <code>d</code> could very well be a valid formula, strange things could result.</p>
<p>We add the step of selecting from [2 3] because trying to reference anything other than /2 or /3 within [2 3] will crash, which is exactly what we want.<span class="intersentencespace"></span> (/1 of [2 3] won’t crash, but this is fine since our test can never produce a -1)</p>
</div>
<div id="cid14" data-tralics-id="cid14" class="section" data-number="4.4"><h2><a href="ch2_nock_macros_fragment.html#cid14" class="heading hyperref"><span class="number">4.4 </span>Nock 9</a></h2>
<div class="code"><div class="highlight"><pre>9r ::     *[a 9 b c]        *[*[a c] *[*[a c] 0 b]] 
</pre></div></div>
<p>We’ll discuss what Nock 9 does in the next chapter, when we introduce how to
use <em>cores</em>, which are subjects containing both code and data.<span class="intersentencespace"></span> If you have a
really fine instinctive sense of Nock, you might understand what <code>9</code> is for.</p>
<p>Succinctly, we use Nock 9 to call a formulas held inside of the subject itself,
and apply them to the subject.<span class="intersentencespace"></span> If you’ve been wondering how one writes Nock
expressions that loop, this is how.</p>
</div>
<div id="cid15" data-tralics-id="cid15" class="section" data-number="4.5"><h2><a href="ch2_nock_macros_fragment.html#cid15" class="heading hyperref"><span class="number">4.5 </span>Nock 10</a></h2>
<div class="code"><div class="highlight"><pre>36 ::    *[a 10 [b c] d]  *[a 8 c 7 [0 3] d]
37 ::    *[a 10 b c]      *[a c]
</pre></div></div>
<p>The second case of 10 is so easy it’s puzzling:</p>
<div class="code"><div class="highlight"><pre>37 ::    *[a 10 b c]      *[a c]
</pre></div></div>
<p>For any <code>b</code>, the formula <code>[10 b c]</code> seems to be perfectly
equivalent to the formula <code>c</code>.<span class="intersentencespace"></span> But why?<span class="intersentencespace"></span> Why would we say
<code>[10 b c]</code> when we could just say <code>c</code>?</p>
<p>The answer is that <code>10</code> is a hint to the interpreter.<span class="intersentencespace"></span> It’s true
that <code>[10 b c]</code> has to be <em>semantically</em> equivalent to <code>c</code>, but
it doesn’t have to be <em>practically</em> equivalent.<span class="intersentencespace"></span> Since whatever
information is in <code>b</code> is discarded, a practical interpreter is
free to ignore it, or to use it in any way that does not affect
the results of the computation.</p>
<p>And the other reduction of <code>10</code>:</p>
<div class="code"><div class="highlight"><pre>    36 ::    *[a 10 [b c] d]  *[a 8 c 7 [0 3] d]
</pre></div></div>
<p>Reducing:</p>
<div class="code"><div class="highlight"><pre>*[a 8 c 7 [0 3] d]

  &lt;&lt;34r::    *[a 8 b c]       *[[*[a b] a] c]&gt;&gt;

*[[*[a c] a] [7 [0 3] d]]

  &lt;&lt;33r::    *[a 7 b c]       *[*[a b] c]&gt;&gt;

*[*[[*[a c] a] 0 3] d]
</pre></div></div>
<p>If you’ve assimilated a bit of Nock already, you may feel the
temptation to reduce this to</p>
<div class="code"><div class="highlight"><pre>*[a d]
</pre></div></div>
<p>since it would be very reasonable to think that</p>
<div class="code"><div class="highlight"><pre>*[[*[a c] a] 0 3]
</pre></div></div>
<p>is just <code>a</code>.<span class="intersentencespace"></span> And it seems to be - given the semantics of 8 as
we’ve explained them.</p>
<p>But there’s a problem, which is that <code>c</code> might not terminate.<span class="intersentencespace"></span> If <code>c</code> terminates, this reduction is correct.<span class="intersentencespace"></span> Otherwise it’s not.
So the best we can do is:</p>
<div class="code"><div class="highlight"><pre>36r::    *[a 10 [b c] d]  *[*[[*[a c] a] 0 3] d]
</pre></div></div>
<p>And that’s it!<span class="intersentencespace"></span> That’s the entirety of the Nock specification!</p>
<div class="code"><div class="highlight"><pre>1  ::    A noun is an atom or a cell.
2  ::    An atom is a natural number.
3  ::    A cell is an ordered pair of nouns.
4  ::
5  ::    nock(a)          *a
6  ::    [a b c]          [a [b c]]
7  ::
8  ::    ?[a b]           0
9  ::    ?a               1
10 ::    +[a b]           +[a b]
11 ::    +a               1 + a
12 ::    =[a a]           0
13 ::    =[a b]           1
14 ::    =a               =a
15 ::
16 ::    /[1 a]           a
17 ::    /[2 a b]         a
18 ::    /[3 a b]         b
19 ::    /[(a + a) b]     /[2 /[a b]]
20 ::    /[(a + a + 1) b] /[3 /[a b]]
21 ::    /a               /a
22 ::
23 ::    *[a [b c] d]     [*[a b c] *[a d]]
24 ::
25 ::    *[a 0 b]         /[b a]
26 ::    *[a 1 b]         b
27 ::    *[a 2 b c]       *[*[a b] *[a c]]
28 ::    *[a 3 b]         ?*[a b]
29 ::    *[a 4 b]         +*[a b]
30 ::    *[a 5 b]         =*[a b]
31 ::
32 ::    *[a 6 b c d]     *[a 2 [0 1] 2 [1 c d] [1 0] 2 [1 2 3] [1 0] 4 4 b]
33 ::    *[a 7 b c]       *[a 2 b 1 c]
34 ::    *[a 8 b c]       *[a 7 [[7 [0 1] b] 0 1] c]
35 ::    *[a 9 b c]       *[a 7 c 2 [0 1] 0 b]
36 ::    *[a 10 [b c] d]  *[a 8 c 7 [0 3] d]
37 ::    *[a 10 b c]      *[a c]
38 ::
39 ::    *a               *a
</pre></div></div>
</div>
    </div>
  </body>
</html>
