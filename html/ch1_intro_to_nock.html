<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link href="stylesheets/pygments.css" media="screen" rel="stylesheet" type="text/css" />
    <link href="stylesheets/softcover.css" media="screen" rel="stylesheet" type="text/css" />
    <link href="stylesheets/custom.css" media="screen" rel="stylesheet" type="text/css" />
    
    <title>urbit_tutorial</title>
    
      <script type="text/x-mathjax-config">
              MathJax.Hub.Config({
        "HTML-CSS": {
          availableFonts: ["TeX"],
        },
        TeX: {
          extensions: ["AMSmath.js", "AMSsymbols.js"],
          equationNumbers: {
            autoNumber: "AMS",
            formatNumber: function (n) { return "3" + '.' + n }
          },
          Macros: {
            PolyTeX:    "Poly{\\TeX}",
            PolyTeXnic: "Poly{\\TeX}nic",
            sig: "\\textasciitilde",
ket: "\\verb+^+",
phep: "\\kode{-{}-}"
          }
        },
        showProcessingMessages: false,
        messageStyle: "none",
        imageFont: null
      });

      </script>
      <script type="text/javascript" src="MathJax/MathJax.js?config=TeX-AMS-MML_SVG"></script>
    
  </head>
  <body>
    
    <div id="book">
      <div id="cid3" data-tralics-id="cid3" class="chapter" data-number="3" data-chapter="ch1_intro_to_nock"><h1><a href="ch1_intro_to_nock_fragment.html#cid3" class="heading hyperref"><span class="number">Chapter 3 </span>Introductory Nock</a></h1>
<blockquote class="quotation"><p class="noindent"><em>What one fool can do, another can.</em></p>
<p style="margin-top: 6.0pt"><span class="break"></span></p>
<p class="noindent">—<strong>Ancient Simian proverb</strong></p>
</blockquote><p>Think of Nock as a kind of functional assembly language.<span class="intersentencespace"></span> It’s not like
assembly language in that it’s directly executed by the hardware.<span class="intersentencespace"></span> It is like
assembly language in that (a) everything in Urbit executes as Nock; (b) you
wouldn’t want to program directly in Nock; and (c) learning to program directly
in Nock is a great way to start understanding Urbit from the ground up.</p>
<p>Just as Unix runs C programs by compiling them to assembler, Urbit runs Hoon
programs by compiling them to Nock.<span class="intersentencespace"></span> You could try to learn Hoon without
learning Nock.<span class="intersentencespace"></span> But just as C is a thin wrapper over the physical CPU, Hoon is
a thin wrapper over the Nock virtual machine.<span class="intersentencespace"></span> It’s a tall stack made of thin
layers, which is much easier to learn a layer at a time.</p>
<p>And unlike most fundamental theories of computing, there’s really nothing smart
or interesting about Nock.<span class="intersentencespace"></span> Of course, in a strictly formal sense, all of
computing is math.<span class="intersentencespace"></span> But that doesn’t mean it needs to feel like math.<span class="intersentencespace"></span> Nock is
a simple mechanical device and it’s meant to feel that way.</p>
<p>Let’s get start by learning how to use Urbit’s operating system, Arvo, to
evaluate Nock code.</p>
</div>
<div id="cid4" data-tralics-id="cid4" class="section" data-number="3.1"><h2><a href="ch1_intro_to_nock_fragment.html#cid4" class="heading hyperref"><span class="number">3.1 </span>Section I: Getting Started</a></h2>
<p>We’ll assume that you’ve gone through the Urbit setup process and have an Arvo
prompt that looks something like this:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; 
</pre></div></div>
<p>At your prompt, type the following exactly:
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(42 [0 1])
</pre></div></div>
<p>This should return <code>42</code>.<span class="intersentencespace"></span> Don’t worry about what this is doing yet.</p>
<p>It’s very important that you actually go to your prompt and type in our
examples.<span class="intersentencespace"></span> Copying and pasting is cheating.<span class="intersentencespace"></span> This might seem silly, but to learn
Nock (or any language) it’s very important that your fingers get
comfortable writing it.</p>
<p>If you accidentally make a mistake typing in a Nock expression, you’ll get a
syntax error:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(42[0 1]) 
~ &lt;syntax error at [1 6]&gt;

~tomsyt-balsen/try=&gt; .*( 42 [0 1]) 
~ &lt;syntax error at [1 4]&gt;
</pre></div></div>
<p>Easiest way to get a sytax error is to accidentally leave out a space.<span class="intersentencespace"></span> Or add
an extra one.<span class="intersentencespace"></span> Fortunately, the error message tells you where the mistake is:</p>
<div class="code"><div class="highlight"><pre>~ &lt;syntax error at [1 4]&gt;
</pre></div></div>
<p>means that there’s an error at <code>line 1</code>, <code>column 4</code>.<span class="intersentencespace"></span> Once you know where an
error is, it’s much easieer to fix.</p>
<p>But even if your Nock expression is formatted correctly, you might get
something that looks like this:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(42 [5 0 1]) 
! exit
</pre></div></div>
<p>This means that the expression you typed in is correct Nock, but it just
doesn’t produce anything.<span class="intersentencespace"></span> Unfortunately, we can’t give you line and column
numbers on this one, so the only surefire way to debug an exit message is to
understand what your code is doing.<span class="intersentencespace"></span> Literally speaking, an exit message means
you tried to do something that just doesn’t make sense.<span class="intersentencespace"></span> Such trying to
reference data that doesn’t exist, or trying to increment something that’s not
a number, or asking if <code>42</code> is equal, without asking what it’s equal to.</p>
<p>Enough about errors, let’s practice some expressions that work:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(41 [0 1]) 
41

~tomsyt-balsen/try=&gt; .*(40 [0 1]) 
40

~tomsyt-balsen/try=&gt; .*(374 [0 1]) 
374
</pre></div></div>
<p>The perceptive reader will notice the pattern here: If a is a number, <code>.*(a [0
1])</code> always produces <code>a</code>.<span class="intersentencespace"></span> To test it, run the following, but
replace <code>a</code> with any number you like.</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(a [0 1]) 
a
</pre></div></div>
<p>Once you’re satisfied that this is true, let’s do something slightly
different:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(374 [1 0]) 
0

~tomsyt-balsen/try=&gt; .*(40 [1 0]) 
0

~tomsyt-balsen/try=&gt; .*(41 [1 0]) /
0
</pre></div></div>
<p>This pattern is pretty easy: <code>*(a [1 0])</code> always produces <code>0</code>, no matter what a
is.</p>
<p>Again, play around with the above yourself by choosing your own values for a:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(a [1 0]) 
0
</pre></div></div>
<p>One more pattern, and then we’ll actually explain what these numbers and brackets represent:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(374 [1 374]) 
374

~tomsyt-balsen/try=&gt; .*(40 [1 374]) 
374

~tomsyt-balsen/try=&gt; .*(374 [1 40]) 
40
</pre></div></div>
<p>As an exercise, run the last three lines again but replace <code>374</code> and <code>40</code> with
number of your own.</p>
<p>You’ve probably already guessed the pattern here: <code>.*(a [1 b])</code> always produces
<code>b</code>, regardless of <code>a</code>.<span class="intersentencespace"></span> But feel free to test it, replacing <code>a</code> and <code>b</code> with any number.</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(a [1 b]) 
b
</pre></div></div>
<p>Let’s run the following piece code again:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(42 [0 1])
</pre></div></div>
<p>Nock is made up of two basic building blocks: atoms, which can be any
non-negative whole number, and cells, which are pairs of numbers or cells
(cells can go inside of other cells.)<span class="intersentencespace"></span> <code>42</code>, for example, is an atom.<span class="intersentencespace"></span> <code>[0 1]</code> is
a cell.<span class="intersentencespace"></span> Even <code>[42 [0 1]]</code> is a cell.<span class="intersentencespace"></span> (It’s very important to note that cells
can nest inside other cells.)</p>
<p>Collectively, both atoms and cells are called nouns.<span class="intersentencespace"></span> And Nock is just a list of
rules (or a set of patterns) for transforming nouns.<span class="intersentencespace"></span> You put one noun in, you
get another noun out.<span class="intersentencespace"></span> It’s like algebra, <code>f(x) = y</code>.<span class="intersentencespace"></span> <code>nock(noun_a) = noun_b</code></p>
<p>The atom <code>42</code> is a noun, the cell <code>[0 1]</code> is a noun, In fact, <code>.*(42 [0 1])</code>
is a noun too, except that its wrapped in syntax that tells Arvo “run
this noun through Nock”.<span class="intersentencespace"></span> <code>.*(42 [0 1])</code> is actually the way to tell Arvo
(Urbit’s operating system) to evaluate <code>Nock([42 [0 1]])</code>.<span class="intersentencespace"></span> The cellular noun
<code>[42 [0 1]]</code> goes into Nock, the atomic noun <code>42</code> comes out.</p>
<p>We could simply write our very first example again as</p>
<div class="code"><div class="highlight"><pre>nock([42 [0 1]]) = 42
</pre></div></div>
<p>except that we wouldn’t be able to evaluate it in Arvo.</p>
<p>Actually, we almost never use the above mathematical notation.<span class="intersentencespace"></span> For the sake of
brevity we almost always write nock(a) using the notation <code>*a</code>.<span class="intersentencespace"></span> Thus, nock([42
[0 1]]) <code>*[42 [0 1]]</code> mean the same thing.<span class="intersentencespace"></span> If we want to tell Arvo to evaluate
the noun, we use <code>.*(42 [0 1])</code>.<span class="intersentencespace"></span> You will notice that the outermost brackets
somewhat confusingly disappear when we use the .*() function in Arvo, we will
explain why in [replaceme: Chapter 2.<span class="intersentencespace"></span> Section 1]</p>
<p>But in documenting Nock, we most frequenly use the <code>*[42 [0 1]]</code> style of
notation:</p>
<p>Instead of, for example, writing</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(a [1 b]) 
b
</pre></div></div>
<p>the standard way of writing out the rules of Nock is</p>
<div class="code"><div class="highlight"><pre>*[a [1 b]]                  b
</pre></div></div>
<p>with the left hand side being the noun that matches our input and the right
side being the product of that input.</p>
<p>We’ve been using <code>a</code> and <code>b</code> as variables that represent numbers (i.e.<span class="intersentencespace"></span> atoms),
but we can and do use them more broadly to represent nouns in general.</p>
<p>Let’s apply the rule</p>
<div class="code"><div class="highlight"><pre>*[a [1 b]]                  b
</pre></div></div>
<p>which, to reiterate, means that when we run any noun of the form [a [1 b]]
through Nock (using the expression <code>.*(a [1 b])</code> in Arvo) always produces <code>b</code>,
regardless of <code>a</code>.</p>
<p>Let’s run a few examples:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(301 [1 374])
374

~tomsyt-balsen/try=&gt; .*([42 43] [1 312])
312

~tomsyt-balsen/try=&gt; .*(374 [1 [44 48]])
[42 43]

~tomsyt-balsen/try=&gt; .*([46 49] [1 [456 539]])
[456 539]

~tomsyt-balsen/try=&gt; .*(374 [1 [[[32 34] 33]])
[[[31 32] 33]
</pre></div></div>
<p>To conclude this section, let’s review what we’ve learned:</p>
<div class="center"><p><rule width="216.81pt" depth="0.0pt" height="0.4pt"></rule></p>
</div>
<div id="uid1" data-tralics-id="uid1" class="subsection" data-number="3.1.1"><h3><a href="ch1_intro_to_nock_fragment.html#uid1" class="heading hyperref"><span class="number">3.1.1 </span>Summary:</a></h3>
<p><strong>Notation:</strong></p>
<p>Arvo syntax:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(42 [0 1]) 
42
</pre></div></div>
<p>Math notation:</p>
<div class="code"><div class="highlight"><pre>nock([42 [0 1]]) = 42
</pre></div></div>
<p>Nock notation:</p>
<div class="code"><div class="highlight"><pre>*[42 [0 1]]                  42
</pre></div></div>
<p><strong>Error Messages:</strong></p>
<p>A syntax error occurs when an expression in Arvo is not typed in correctly.</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*( 42 [0 1]) 
~ &lt;syntax error at [1 4]&gt;
</pre></div></div>
<p>The cell in the syntax error gives the line and column number of the location of the error.</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(42 [5 0 2]) 
! exit
</pre></div></div>
<p><strong>Structures:</strong></p>
<p>A noun is an atom or a cell.<span class="intersentencespace"></span> An atom is a natural number.<span class="intersentencespace"></span> A cell is an
ordered pair of two nouns.<span class="intersentencespace"></span> I.e.<span class="intersentencespace"></span> two atoms, two cells, or a cell and an atom.</p>
<p><strong>Nock Rules</strong></p>
<p>Lower-case letters such as <code>a</code> or <code>b</code> are variables that represent nouns.</p>
<p>Nock rules are notated with two columns, where the left hand side indicates
what pattern the noun matches, and the right hand side indicates what the noun
produces.<span class="intersentencespace"></span> </p><div class="code"><div class="highlight"><pre>*[a [0 1]]                  a
*[a [1 b]]                  b
</pre></div></div>
<p>___</p>
</div>
<div id="uid2" data-tralics-id="uid2" class="subsection" data-number="3.1.2"><h3><a href="ch1_intro_to_nock_fragment.html#uid2" class="heading hyperref"><span class="number">3.1.2 </span>Exercises:</a></h3>
<ol><li>Take the noun [[a b] c] and replace each of <code>a</code> <code>b</code> and <code>c</code> with a cell.<span class="intersentencespace"></span> Test your cell by applying, in Arvo using the correct syntax, the rule:
<div class="code"><div class="highlight"><pre>*[a [0 1]]                  a
</pre></div></div>
</li>
<li>Write a cell that contains 12 atoms.<span class="intersentencespace"></span> Test your cell by applying, in Arvo using the correct syntax, the rule:
<div class="code"><div class="highlight"><pre>*[a [1 b]]                  b
</pre></div></div>
<p>setting <code>a</code> eqaul to <code>1</code>.<span class="intersentencespace"></span></p>
</li>
<li>Produce a syntax error that reads:
<div class="code"><div class="highlight"><pre>~ &lt;syntax error at [1 14]&gt;
</pre></div></div>
</li>
<li>With pen and paper, write out all three possible forms of notation for each
of the expressions you evaluated in exercises 1.<span class="intersentencespace"></span> and 2.<span class="intersentencespace"></span>
</li></ol><div class="center"><p><rule width="216.81pt" depth="0.0pt" height="0.4pt"></rule></p>
</div></div></div>
<div id="cid5" data-tralics-id="cid5" class="section" data-number="3.2"><h2><a href="ch1_intro_to_nock_fragment.html#cid5" class="heading hyperref"><span class="number">3.2 </span>Section II: Noun Structure</a></h2>
<p>Last section we played around with this:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(42 [0 1])
42
</pre></div></div>
<p>which corresponds to the pattern
</p><div class="code"><div class="highlight"><pre>*[a [0 1]]                  a
</pre></div></div>
<p>Now we’re going to experiment with what happens when we replace <code>1</code> with
different values.<span class="intersentencespace"></span> Remember, as you follow along, type out the examples at your
own Arvo prompt.<span class="intersentencespace"></span> </p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 43] [0 1])
[42 43]

~tomsyt-balsen/try=&gt; .*([42 43] [0 2])
42

~tomsyt-balsen/try=&gt; .*([42 43] [0 3])
43

~tomsyt-balsen/try=&gt; .*([42 43] [0 4])
! exit
</pre></div></div>
<p>We don’t really have enough examples to figure out the pattern yet.<span class="intersentencespace"></span> Let’s
change <code>[42 43]</code> to <code>[[44 45] 43]</code> and try some more.<span class="intersentencespace"></span> </p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([[44 45] 43] [0 1])
[[44 45] 43] 

~tomsyt-balsen/try=&gt; .*([[44 45] 43] [0 2])
[44 45]

~tomsyt-balsen/try=&gt; .*([[44 45] 43] [0 3])
43

~tomsyt-balsen/try=&gt; .*([[44 45] 43] [0 4])
44

~tomsyt-balsen/try=&gt; .*([[44 45] 43] [0 5])
45

~tomsyt-balsen/try=&gt; .*([[44 45] 43] [0 6])
! exit
</pre></div></div>
<p>It looks like anything of the form <code>*[a [0 b]]</code> produces the sub-nouns that are
inside of a.<span class="intersentencespace"></span> Remember that notationally, <code>*[a [0 b]]</code> is the same as <code>.*(a [0
b])</code> e.g.<span class="intersentencespace"></span> a is <code>[[44 45] 43]</code> and b is one of the atoms <code>1</code> through <code>6</code>.</p>
<p>But how does <code>*[a [0 b]]</code> know which pieces of a to choose?</p>
<p>Let’s do one more example and then we’ll explain it.<span class="intersentencespace"></span> </p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 [46 47]] [0 1])
[42 [46 47]] 

~tomsyt-balsen/try=&gt; .*([42 [46 47]] [0 2])
42

~tomsyt-balsen/try=&gt; .*([42 [46 47]] [0 3])
[46 47]

~tomsyt-balsen/try=&gt; .*([42 [46 47]] [0 4])
! exit

~tomsyt-balsen/try=&gt; .*([42 [46 47]] [0 5])
! exit

~tomsyt-balsen/try=&gt; .*([42 [46 47]] [0 6])
46

~tomsyt-balsen/try=&gt; .*([42 [46 47]] [0 7])
47
</pre></div></div>
<p>Try to solve this puzzle on your own by playing with the following:
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(a [0 b])
</pre></div></div>
<p>where <code>a</code> is a cell and <code>b</code> is an atom.<span class="intersentencespace"></span> Try to pick atoms for <code>b</code> that are
small and try to pick cells for <code>a</code> that have lots of nesting.</p>
<p>When you’re ready to have things explained to you, read on.</p>
<p>Think of a noun as a tree structure:
</p><div class="code"><div class="highlight"><pre>  [42 [46 47]]
  /       \
42      [46 47]]
          / \ 
        46   47
</pre></div></div>
<p>Every cell has two branches (the head of the cell and the tail) leading down
from it.<span class="intersentencespace"></span> Atoms have no branches, because they can’t be broken down any further
(and this is exactly why they’re called atoms).</p>
<p>Let’s look at the tree of the other noun we played with, <code>[[44 45] 43]</code>:
</p><div class="code"><div class="highlight"><pre> [[44 45] 43]
    /      \
[44 45]    43
 /   \
44   45
</pre></div></div>
<p>It should be pretty obvious that we could change the values of any of the atoms
in the tree without changing the structure of the tree.<span class="intersentencespace"></span> That is to say, <code>[[44
45] 43]</code> and <code>[[24 25] 23]</code> have the same tree structure:
</p><div class="code"><div class="highlight"><pre> [[22 25] 23]
    /      \
[22 25]    23
 /   \
22   25
</pre></div></div>
<p>And now, for a more complicated tree, here’s the noun <code>[[[48 49] 45] [46 47]]</code>:
</p><div class="code"><div class="highlight"><pre>  [[[48 49] 45] [46 47]]
       /            \
 [[48 49] 45]      [46 47]
   /       \        /   \
[48 49]    45      46   47
 /   \
48   49
</pre></div></div>
<p>So how do the above trees relate to running <code>.*(a [0 b])</code>?<span class="intersentencespace"></span> Simple, every part
of the tree gets mapped to an atomic address (we call it an axis).<span class="intersentencespace"></span> The mapping
looks something like this:
</p><div class="code"><div class="highlight"><pre>           1 
       /       \
     2           3          
   /   \       /   \
  4     5     6     7     
 / \   / \   / \   / \
8   9 10 11 12 13 14 15
</pre></div></div>
<p>Or, because the lines are kind of ugly:
</p><div class="code"><div class="highlight"><pre>         1
    2          3
 4    5     6     7
8 9 10 11 12 13 14 15
</pre></div></div>
<p>Of course, this only a very small part of the entire tree.<span class="intersentencespace"></span> We extend the tree
by applying the rule: Every axis <code>/n</code> has a head with the axis<code>/2n</code> and a tail
with the axis<code>/2n+1</code>”</p>
<p>We map from noun to axis by comparing the tree of the noun with the axis tree
and seeing what matches.<span class="intersentencespace"></span> Like so, marking axes with a <code>/</code> character:
</p><div class="code"><div class="highlight"><pre>  /1 : [[44 45] 43]
         /        \
 /2 : [44 45]     43 : /3
      /     \
/4 : 44      45 : /5
</pre></div></div>
<p>Again, because it bears repeating: the head of axis <code>/n</code> is <code>/2n</code> and the tail
of axis <code>/n</code> is <code>/2n+1</code>.<span class="intersentencespace"></span> Remember that the head is the left-hand noun and the
tail the right-hand noun of a cell-pair.</p>
<p>Start with 1.<span class="intersentencespace"></span> This is your root axis.<span class="intersentencespace"></span> All nouns have a valid axis <code>/1</code>, even
atoms.<span class="intersentencespace"></span> and the axis <code>/1</code> just refers to the noun itself.<span class="intersentencespace"></span> In the above example,
axis /1 of <code>[[44 45] 43]</code> is just <code>[[44 45] 43]</code>.<span class="intersentencespace"></span> The head of <code>[[44 45] 43]</code> is
<code>[44 45]</code> and the tail is <code>43</code>.<span class="intersentencespace"></span> Thus, axis <code>/2</code> of <code>[[44 45] 43]</code> is <code>[44 45]</code>
and axis /3 is <code>43</code>.</p>
<p>Another way to think about it is that the tree map has layers:
</p><div class="code"><div class="highlight"><pre>layer 0             1
layer 1        2          3
layer 2     4    5     6     7
layer 3    8 9 10 11 12 13 14 15
</pre></div></div>
<p>which correspond to the nesting depth of the noun.<span class="intersentencespace"></span> If a noun is inside two
cells, like <code>46</code> inside <code>[[[48 49] 45] [46 47]]</code> then its axis is at layer 2 of
the tree.<span class="intersentencespace"></span> If its inside three cells like <code>48</code>, then its axis is at layer
three.</p>
<p>Recall the pattern we learned in section 1:
</p><div class="code"><div class="highlight"><pre>*[a [0 1]]                  a
</pre></div></div>
<p>This, we now see, is a special case of
</p><div class="code"><div class="highlight"><pre>*[a [0 b]]              axis /b of a
</pre></div></div>
<p>The 0 in <code>*[a [0 b]]</code> is just an operator that means axis.<span class="intersentencespace"></span> Nock maps simple
operators and functions to atoms, instead of a character like <code>/</code> for example,
because atoms (and cells) are all Nock knows.<span class="intersentencespace"></span> This would Fortunately for us,
there are only eleven atoms that are operators, atoms <code>0</code> through <code>10.</code></p>
<div class="center"><p><rule width="216.81pt" depth="0.0pt" height="0.4pt"></rule></p>
</div>
<div id="uid7" data-tralics-id="uid7" class="subsection" data-number="3.2.1"><h3><a href="ch1_intro_to_nock_fragment.html#uid7" class="heading hyperref"><span class="number">3.2.1 </span>Summary:</a></h3>
<p><strong>Noun structure:</strong></p>
<p>Nouns are trees that look like this:
</p><div class="code"><div class="highlight"><pre> [[44 45] 43]
    /      \
[44 45]    43
 /   \
44   45
</pre></div></div>
<p>The left-hand of a cell is called the head.<span class="intersentencespace"></span> The right hand is the tail.</p>
<p><strong>Axes:</strong></p>
<p>An axis is the address of a node of the noun tree.</p>
<p>The notation for axis n is /n.</p>
<p>The first part of the axis tree looks like this:
</p><div class="code"><div class="highlight"><pre>         1
    2          3
 4    5     6     7
8 9 10 11 12 13 14 15
</pre></div></div>
<p>The head of axis /n is /(2n) and the tail of axis /n is /(2n+1).</p>
<p><strong>Nock Operators:</strong></p>
<p>The operators in Nock are functions mapped onto the eleven atoms <code>0</code> through <code>10</code>.</p>
<p><strong>Nock 0:</strong></p>
<p>The Nock operator that produces a given axis of a noun:
</p><div class="code"><div class="highlight"><pre>*[a [0 b]]               /b of a
</pre></div></div>
<p>___</p>
</div>
<div id="uid8" data-tralics-id="uid8" class="subsection" data-number="3.2.2"><h3><a href="ch1_intro_to_nock_fragment.html#uid8" class="heading hyperref"><span class="number">3.2.2 </span>Exercises:</a></h3>
<ol><li>Take pen and paper and map out the axes of
<div class="code"><div class="highlight"><pre>   [[[48 49] 45] [46 47]]
       /             \
 [[48 49] 45]      [46 47]
   /       \        /   \
[48 49]    45      46   47
 /   \
48   49
</pre></div></div>
<p>then to test yourself, run:
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([[[48 49] 45] [46 47]] [0 b])
</pre></div></div>
<p>for each axis <code>/b</code> of <code>[[[48 49] 45] [46 47]]</code></p>
</li>
<li>Write a noun <code>a</code> such that the following produces something:
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(a [0 100])
</pre></div></div>
<p>In other words, find a noun that has an axis <code>/100</code>.<span class="intersentencespace"></span></p>
</li>
<li>Prune your noun from the last exercis so that its as short as possible,
while still having an axis <code>/100</code>.<span class="intersentencespace"></span>
</li>
<li>If you still feel confused, replicate the previous two exercises with the
axes <code>/7</code>, ‘/17’, ‘/27’, ‘/47’ and <code>/87</code>.<span class="intersentencespace"></span>
</li>
<li>Build a noun that has every atom set to its own axis.<span class="intersentencespace"></span> The bigger the noun
the better.<span class="intersentencespace"></span> I’ll get you started:
<div class="code"><div class="highlight"><pre>1
[2 3]
[[4 5] 3]
[[4 5] [6 7]
</pre></div></div>
<p>To test different atoms in your noun, run
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(a [0 b])
</pre></div></div>
<p>___</p>
</li></ol></div></div>
<div id="cid6" data-tralics-id="cid6" class="section" data-number="3.3"><h2><a href="ch1_intro_to_nock_fragment.html#cid6" class="heading hyperref"><span class="number">3.3 </span>Section III: Nock 3</a></h2>
<p>In the last section we learned how to access data inside nouns.<span class="intersentencespace"></span> Now we’re going
to learn what you can do with data.<span class="intersentencespace"></span> After all, Nock is a computer, so you
should be able to, you know, compute things.</p>
<p>We mentioned in the last section that Nock has eleven operators, <code>0</code> through
<code>10</code>.<span class="intersentencespace"></span> We saw <code>Nock 1</code> in Section I:
</p><div class="code"><div class="highlight"><pre>*[a [1 b]]                  b
</pre></div></div>
<p>We could describe <code>Nock </code>1 the constant operator, since it always produces <code>b</code>
no matter what you put in as a.</p>
<p>We also have <code>Nock 0</code>, which lets you refer to the sub-noun at the <code>axis b</code> of
your subject <code>a</code>.
</p><div class="code"><div class="highlight"><pre>*[a [0 b]]               /b of a
</pre></div></div>
<p>We’re going to skip <code>Nock 2</code> and cover it in Section V and for now just jump
straight to <code>Nock 3</code>.</p>
<p>Before we do, let’s quickly go over three new terms that’ll help us talk about
operators:</p>
<p>Let’s say you have the Nock expression
</p><div class="code"><div class="highlight"><pre>*[a [1 b]] 
</pre></div></div>
<p>We know that <code>1</code> is the operator, but shouldn’t we have names for what <code>a</code> and
<code>b</code> are?</p>
<p>Let’s call <code>a</code> the subject, because it’s being subjected to our computation.<span class="intersentencespace"></span> Poor <code>a</code>.</p>
<p>We’ll call <code>b</code> an argument, And we’ll call the cell <code>[1 b]</code> a formula.<span class="intersentencespace"></span> Diagramming it out:
</p><div class="code"><div class="highlight"><pre>*[a [1 b]] 
*[subject [operator argument]]
*[subject formula]
</pre></div></div>
<p>Good, now that we’ve got vocab out of the way, let’s get cooking.</p>
<p>Let’s use the big noun <code>[[[48 49] 45] [46 47]]</code> from the last section as our subject.
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt;.*([[[48 49] 45] [46 47]] [3 0])
! exit
</pre></div></div>
<p>Uh-oh, Arvo is telling us we just tried to do something indecent and unnatural.
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt;.*([[[48 49] 45] [46 47]] [3 1])
! exit

~tomsyt-balsen/try=&gt;.*([[[48 49] 45] [46 47]] [3 2])
! exit

~tomsyt-balsen/try=&gt;.*([[[48 49] 45] [46 47]] [3 3])
! exit

~tomsyt-balsen/try=&gt;.*([[[48 49] 45] [46 47]] [3 4])
! exit
</pre></div></div>
<p>Looks like <code>Nock 3</code> doesn’t like an atomic argument.<span class="intersentencespace"></span> Let’s go cellular.<span class="intersentencespace"></span> </p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt;.*([[[48 49] 45] [46 47]] [3 [0 1]])
0
</pre></div></div>
<p>Okay, so at least that does something.</p>
<p>Let’s try some more:
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt;.*([[[48 49] 45] [46 47]] [3 [0 2]])
0

~tomsyt-balsen/try=&gt;.*([[[48 49] 45] [46 47]] [3 [0 3]])
0

~tomsyt-balsen/try=&gt;.*([[[48 49] 45] [46 47]] [3 [0 4]])
0

~tomsyt-balsen/try=&gt;.*([[[48 49] 45] [46 47]] [3 [0 5]])
1
</pre></div></div>
<p>Wait, what?</p>
<p>Hold on, aren’t <code>[0 1]</code> or <code>[0 5]</code> valid Nock formulas on their own?<span class="intersentencespace"></span> If <code>3</code>
only takes cells, and formulas are cells, maybe it matters what the formula
does on its own.</p>
<p>Let’s try that sequence again without <code>Nock 3</code>:
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt;.*([[[48 49] 45] [46 47]] [0 1])
[[[48 49] 45] [46 47]]

~tomsyt-balsen/try=&gt;.*([[[48 49] 45] [46 47]] [0 2])
[[48 49] 45]

~tomsyt-balsen/try=&gt;.*([[[48 49] 45] [46 47]] [0 3])
[46 47]

~tomsyt-balsen/try=&gt;.*([[[48 49] 45] [46 47]] [0 4])
[48 49]

~tomsyt-balsen/try=&gt;.*([[[48 49] 45] [46 47]] [0 5])
45
</pre></div></div>
<p>One of these things is not like the others.<span class="intersentencespace"></span> Looks like something changes
whether the formula <code>[0 n]</code> refers to an atom or a cell in our subject.</p>
<p>Let’s see what happens if we run Nock 3 with <code>[0 1]</code> as its argument and try
some different subjects:
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt;.*([42 42] [3 [0 1]])
0

~tomsyt-balsen/try=&gt;.*(42 [3 [0 1]])
1

~tomsyt-balsen/try=&gt;.*([1 1] [3 [0 1]])
0

~tomsyt-balsen/try=&gt;.*(1 [3 [0 1]])
1
</pre></div></div>
<p>Looks like that’s <code>0</code> for cells and <code>1</code> for atoms.<span class="intersentencespace"></span> Which means that <code>Nock 3</code> is
cell/atom tester.</p>
<p>How’s that work?</p>
<p><code>Nock 3</code>’s argument is itself a formula.<span class="intersentencespace"></span> Let’s call it <code>b</code>.<span class="intersentencespace"></span> </p><div class="code"><div class="highlight"><pre>*[subject-a [3 formula-b]]
</pre></div></div>
<p><code>Nock 3</code> produces either a <code>0</code> or a <code>1</code>, depending on what formula-b does when
applied to subject-a:
</p><div class="code"><div class="highlight"><pre>*[subject-a formula-b]
</pre></div></div>
<p>Or more simply:
</p><div class="code"><div class="highlight"><pre>*[a b]
</pre></div></div>
<p>If <code>*[a b]</code> produces a cell, then <code>*[a [3 b]]</code> produces 0.<span class="intersentencespace"></span> If <code>*[a b]</code> produces
an atom, <code>*[a [3 b]]</code> produces 1.<span class="intersentencespace"></span> So our pattern for Nock 3 is:
</p><div class="code"><div class="highlight"><pre>*[a [3 b]]         ?(*[a b])
?(cell)            0
?(atom)            1
</pre></div></div>
<p><code>?(x)</code> is just a litte functional notation so that we can write out both possible branches.</p>
<p>We should also note that Urbit uses the atom <code>0</code> to mean “yes” and the atom <code>1</code>
to mean “no.”<span class="intersentencespace"></span> (this may seem different and annoying.<span class="intersentencespace"></span> it is, but it’s
the same thing that Unix does).</p>
<p>In that context, <code>Nock </code>3 is just asking the question “Is the product of these two nouns a cell?</p>
<p>Let’s review what we’ve learned:</p>
<div class="center"><p><rule width="216.81pt" depth="0.0pt" height="0.4pt"></rule></p>
</div>
<div id="uid14" data-tralics-id="uid14" class="subsection" data-number="3.3.1"><h3><a href="ch1_intro_to_nock_fragment.html#uid14" class="heading hyperref"><span class="number">3.3.1 </span>Summary:</a></h3>
<p><strong>Vocabulary:</strong></p>
<p>The subject is the noun that gets computed.</p>
<p>The operator is an atom that tells us how to Nock the subject and arguments.</p>
<p>The arguments modify the behaviour of the operator.</p>
<p>A formula is a cell of <code>[operator arguments]</code></p>
<p>As a chart:
</p><div class="code"><div class="highlight"><pre>*[a [1 b]] 
*[subject [operator arguments]]
*[subject formula]
</pre></div></div>
<p><strong>Yes and No</strong></p>
<p>Atom 0 means “yes”
Atom 1 means “no.”</p>
<p><strong>Nock 3</strong></p>
<p>Nock 3 is a cell tester.<span class="intersentencespace"></span> </p><div class="code"><div class="highlight"><pre>*[a [3 b]]         ?(*[a b])
?(cell)            0
?(atom)            1
</pre></div></div>
<p>___</p>
</div>
<div id="uid15" data-tralics-id="uid15" class="subsection" data-number="3.3.2"><h3><a href="ch1_intro_to_nock_fragment.html#uid15" class="heading hyperref"><span class="number">3.3.2 </span>Exercises:</a></h3>
<ol><li>Run and compare
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt;.*(a b)
</pre></div></div>
<p>and
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt;.*(a [3 b])
</pre></div></div>
<p>with different values for a and b.<span class="intersentencespace"></span></p>
</li>
<li>Try finding a value for <code>b</code> that will return <code>1</code> if <code>a</code> is the atom <code>42</code>:
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt;.*(42 [3 b])
</pre></div></div>
<p>Not only is this possible, but you already know the formula to do it.<span class="intersentencespace"></span> ___</p>
</li></ol></div></div>
<div id="cid7" data-tralics-id="cid7" class="section" data-number="3.4"><h2><a href="ch1_intro_to_nock_fragment.html#cid7" class="heading hyperref"><span class="number">3.4 </span>Section IV: Nock 4</a></h2>
<p>Last section we learned how to test whether a noun is an atom or a cell with
<code>Nock 3</code>.<span class="intersentencespace"></span> Now we’re going to figure out what <code>Nock 4</code> does.</p>
<p>Let’s start playing with <code>Nock 4</code>, using <code>[[44 45] 46]</code> as our subject:
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt;.*([[44 45] 46] [4 0])
! exit

~tomsyt-balsen/try=&gt;.*([[44 45] 46] [4 1])
! exit

~tomsyt-balsen/try=&gt;.*([[44 45] 46] [4 2])
! exit
</pre></div></div>
<p>Okay, this is starting to feel a lot like <code>Nock 3</code>.<span class="intersentencespace"></span> Looks like <code>Nock 4</code> doesn’t
like atoms either.<span class="intersentencespace"></span> Remember that <code>Nock 3</code> took a cell that was a formula as its
argument:
</p><div class="code"><div class="highlight"><pre>*[subject [3 formula]]
</pre></div></div>
<p>And then depending on what the expression
</p><div class="code"><div class="highlight"><pre>*[subject formula]
</pre></div></div>
<p>produced, <code>Nock 3</code> would return a <code>0</code> or <code>1</code>, according to the function <code>?(x)</code>
that we defined:
</p><div class="code"><div class="highlight"><pre>*[a [3 b]]         ?(*[a b])
?(cell)            0
?(atom)            1
</pre></div></div>
<p>Let’s assume that Nock 4 operates in a similar way.<span class="intersentencespace"></span> Let’s use the formula <code>[0
n]</code> to try to apply Nock 4 to different axes in our subject:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt;.*([[44 45] 46] [4 [0 1]])
! exit

~tomsyt-balsen/try=&gt;.*([[44 45] 46] [4 [0 2]])
! exit

~tomsyt-balsen/try=&gt;.*([[44 45] 46] [4 [0 3]])
47
</pre></div></div>
<p>Well!<span class="intersentencespace"></span> That’s blessedly simple then.<span class="intersentencespace"></span> Watch:
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt;.*([[44 45] 46] [0 3])
46

~tomsyt-balsen/try=&gt;.*([[44 45] 46] [4 [0 3]])
47
</pre></div></div>
<p>Can you guess what
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt;.*([[44 45] 46] [4 [0 4]])
</pre></div></div>
<p>would produce?</p>
<p>If you said
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt;.*([[44 45] 46] [4 [0 4]])
45
</pre></div></div>
<p>then you’re starting to get the hang of this.<span class="intersentencespace"></span> Yes, ladies and gentlemen, <code>Nock
4</code> is increment.<span class="intersentencespace"></span> Nock together your subject and the formula in your argument,
and whatever that produces, add 1 to it.</p>
<p>But what if <code>*[subject formula]</code> produces a cell instead of an atom?<span class="intersentencespace"></span> How do we
add <code>1</code> to a cell?<span class="intersentencespace"></span> Simple, we don’t.<span class="intersentencespace"></span> The sun continues to rise in the east,
pigs remain regretfully earthbound, Hell is still rather toasty, and
incrementing a cell in Nock produces an !<span class="intersentencespace"></span> exit:
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt;.*([[44 45] 46] [4 [0 2]])
! exit
</pre></div></div>
<p>Assuming we understood how <code>Nock 3</code> worked, writing dow our pattern for <code>Nock 4</code> is easy:</p>
<p>Nock 3:
</p><div class="code"><div class="highlight"><pre>*[a [3 b]]         ?(*[a b])
?(cell)            0
?(atom)            1
</pre></div></div>
<p>Nock 4:
</p><div class="code"><div class="highlight"><pre>*[a [4 b]]         +(*[a b])
+(cell)            ! exit
+(atom)            1 + atom
</pre></div></div>
<p><code>+(x)</code> is, again, just some notation so we can write out both branches of Nock
4.</p>
<p>An interesting property of Nock 4 is that we can chain it together to
increment successive times.<span class="intersentencespace"></span> </p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt;.*(44 [4 [0 1]])
45

~tomsyt-balsen/try=&gt;.*(44 [4 [4 [0 4]]])
46

~tomsyt-balsen/try=&gt;.*(44 [4 [4 [4 [0 4]]]])
47

~tomsyt-balsen/try=&gt;.*(44 [4 [4 [4 [4 [0 4]]]]])
48

~tomsyt-balsen/try=&gt;.*(44 [4 [4 [4 [4 [4 [0 4]]]]]])
49
</pre></div></div>
<p>Those brackets are starting to really pile up.<span class="intersentencespace"></span> Which is making this whole
process a lot less legible than we would like.</p>
<p>Fortunatley Nock has a notational rule that’ll let us not have to write so many
of those brackets.<span class="intersentencespace"></span> </p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt;.*(44 [4 [4 [4 [4 [4 [0 4]]]]]])
49

~tomsyt-balsen/try=&gt;.*(44 [4 4 4 4 4 0 4])
49
</pre></div></div>
<p>Woah.<span class="intersentencespace"></span> That’s a lot cleaner.</p>
<p>Concisely, Nock considers brackets to group to the right.<span class="intersentencespace"></span> If you’ll recall from back in section 1:
</p><div class="code"><div class="highlight"><pre>A noun is an atom or a cell.
An atom is a natural number.
A cell is an ordered pair of two nouns. I.e. two atoms, two cells, or a cell and an atom.
</pre></div></div>
<p>Which means that formally, all nouns in Nock are either singletons (atoms) or
cells (pairs).<span class="intersentencespace"></span> There are no triples, quadruples, or n-tuples:
</p><div class="code"><div class="highlight"><pre>[a b c]
[a b c d]
[a b c d e]
</pre></div></div>
<p>etc.</p>
<p>But because a triple like [a b c] doesn’t exist in Nock, but is easier on the
eyes, we can map a nested pair onto it.<span class="intersentencespace"></span> </p><div class="code"><div class="highlight"><pre>[a b c]         [a [b c]]
</pre></div></div>
<p>Which means that the Nock interpreter, whenever it sees a triple (or any
n-tuple, for n&gt;2), just inserts the needed brackets.</p>
<p>Let’s do some more examples to help you get the hang of it:
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt;.*(44 [4 [4 [4 [4 [4 0 1]]]]])
49

~tomsyt-balsen/try=&gt;.*(44 [4 [4 [4 [4 4 0 1]]]])
49

~tomsyt-balsen/try=&gt;.*(44 [4 [4 [4 4 4 0 1]]])
49

~tomsyt-balsen/try=&gt;.*(44 [4 [4 4 4 4 0 1]])
49

~tomsyt-balsen/try=&gt;.*(44 [4 4 4 4 4 0 1])
49
</pre></div></div>
<p>We can’t get rid of the last pair though:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt;.*(44 4 4 4 4 4 0 1)
~ &lt;syntax error at [1 18]&gt;
</pre></div></div>
<p>This is just an artifact of Arvo’s Nock interpreter, which we directly access
with the <code>.*</code> function, pronounced <code>dottar</code> (dot-star, get it?).<span class="intersentencespace"></span> <code>.*</code> takes two
arguments, a subject and a formula:
</p><div class="code"><div class="highlight"><pre>.*(subject [formula])
</pre></div></div>
<p>And for inscrutable reasons, the formula has to be in brackets.<span class="intersentencespace"></span> As does the
subject, if it’s a cell:
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt;.*(44 45 [4 4 4 4 4 0 2])
~ &lt;syntax error at [1 9]&gt;

~tomsyt-balsen/try=&gt;.*([44 45] [4 4 4 4 4 0 2])
49
</pre></div></div>
<p>Let’s review:</p>
<div class="center"><p><rule width="216.81pt" depth="0.0pt" height="0.4pt"></rule></p>
</div>
<div id="uid18" data-tralics-id="uid18" class="subsection" data-number="3.4.1"><h3><a href="ch1_intro_to_nock_fragment.html#uid18" class="heading hyperref"><span class="number">3.4.1 </span>Summary:</a></h3>
<p><strong>Nock 4:</strong>
</p><div class="code"><div class="highlight"><pre>*[a [4 b]]         +(*[a b])
+(cell)            ! exit
+(atom)            1 + atom
</pre></div></div>
<p><strong>Brackets:</strong></p>
<p>Brackets group to the right.<span class="intersentencespace"></span> </p><div class="code"><div class="highlight"><pre>[a b c]         [a [b c]]
</pre></div></div>
<p><strong>Nock interpreter:</strong></p>
<p><code>.*</code> is pronounced “dottar”</p>
<p>Takes two arguments, subject and formula:
</p><div class="code"><div class="highlight"><pre>.*(subject [formula])
</pre></div></div>
<p>formula must be bracketed.</p>
<div class="center"><p><rule width="216.81pt" depth="0.0pt" height="0.4pt"></rule></p>
</div></div>
<div id="uid19" data-tralics-id="uid19" class="subsection" data-number="3.4.2"><h3><a href="ch1_intro_to_nock_fragment.html#uid19" class="heading hyperref"><span class="number">3.4.2 </span>Exercises:</a></h3>
<ol><li>Chain together Nock 4 and Nock 3, so that cells produce 2 and atoms produce 3.<span class="intersentencespace"></span>
</li>
<li>Write a formula that always returns the cell [4 0 1].<span class="intersentencespace"></span>
</li></ol></div></div>
<div id="cid8" data-tralics-id="cid8" class="section" data-number="3.5"><h2><a href="ch1_intro_to_nock_fragment.html#cid8" class="heading hyperref"><span class="number">3.5 </span>Section V: Nock 5, Nock 2 and Formula Distribution</a></h2>
<p>So we’ve learned how to do some simple operations with Nock.<span class="intersentencespace"></span> Now we’re going to get a little fancier.</p>
<p>To jog your memory, we’ve seen the following operators so far:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 43] [0 1])
[42 43]

~tomsyt-balsen/try=&gt; .*([42 43] [1 0])
[42 43]

~tomsyt-balsen/try=&gt; .*([42 43] [3 0 1])
0

~tomsyt-balsen/try=&gt; .*([42 43] [4 0 2])
43
</pre></div></div>
<p>These have all had the following pattern in common:</p>
<div class="code"><div class="highlight"><pre>*[subject [operator arguments]]
</pre></div></div>
<p>with the atomic operator (0, 1, 3 or 4).</p>
<p>What if we replaced that atom with a cell?<span class="intersentencespace"></span> With a formula, even?<span class="intersentencespace"></span> Let’s try it:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(42 [[0 1] 0 1])
[42 42]
</pre></div></div>
<p>Well that’s different.<span class="intersentencespace"></span> Let’s try another subject:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 43] [[0 1] 0 1])
[[42 43] 42 43]
</pre></div></div>
<p>And if we change the formulas?</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 43] [[0 2] 0 1])
[42 42 43]

~tomsyt-balsen/try=&gt; .*([42 43] [[0 2] 0 2])
[42 42]

~tomsyt-balsen/try=&gt; .*([42 43] [[0 1] 0 2])
[[42 43] 42]
</pre></div></div>
<p>It looks like its running both formulas and then just combining the results in a cell.</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 43] [[3 0 1] 3 0 2])
[0 1]

~tomsyt-balsen/try=&gt; .*([42 43] [[3 0 1] 4 0 3])
[0 44]

~tomsyt-balsen/try=&gt; .*([42 43] [[1 [0 1]] 4 0 3])
[[0 1] 44]

~tomsyt-balsen/try=&gt; .*([42 43] [[4 0 3] 1 [0 1]])
[44 [0 1]]
</pre></div></div>
<p>Yup, the subject is definitely running through both formulas in parallel.<span class="intersentencespace"></span> The
last example seems to do something like this:</p>
<div class="code"><div class="highlight"><pre>*[[42 43] [4 0 3] 1 [55 73]]         [*[[42 43] [4 0 3]] *[[42 43] 1 [55 73]]]
</pre></div></div>
<p>which we can evaluate using Arvo:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 43] [4 0 3])
44

~tomsyt-balsen/try=&gt; .*([42 43] [1 [0 1]])
[0 1]
</pre></div></div>
<p>Or by hand, which is good practice.<span class="intersentencespace"></span> Open up a blank text file or grab a pen and
copy along:</p>
<div class="code"><div class="highlight"><pre>*[[42 43] [4 0 3] 1 [0 1]]  [*[[42 43] [4 0 3]] *[[42 43] 1 [0 1]]]

&lt;&lt;  Nock 4:       *[a [4 b]]          +(*[a b]) &gt;&gt;

[+(*[[42 43] 0 3]]) *[[42 43] 1 [0 1]]]

&lt;&lt;  Nock 0:       *[a [0 b]]          /b of a  &gt;&gt;
       
[+(43) *[[42 43] 1 [0 1]]]

&lt;&lt;     +():       +(atom)             1 + atom  &gt;&gt;

[44 *[[42 43] 1 [0 1]]]

&lt;&lt;  Nock 1:       *[a [1 b]]          b  &gt;&gt;

[44 [0 1]] 
</pre></div></div>
<p>Thus,</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 43] [[4 0 3] 1 [0 1]])
[44 [0 1]]
</pre></div></div>
<p>We could write the first line of the reduction more generally as</p>
<div class="code"><div class="highlight"><pre>*[subject [formula1] formula2]     [*[subject formula1] *[subject formula2]]   
</pre></div></div>
<p>Which is a little long for my taste, since a formula is a cell we can rewrite it as:</p>
<div class="code"><div class="highlight"><pre>*[a [b c] d e]     [*[a b c] *[a d e]]   
</pre></div></div>
<p>where a is the subject, [b c] is formula1 and [d e] is formula2.</p>
<p>But actually we can simplify this further and just say:</p>
<div class="code"><div class="highlight"><pre>*[a [b c] d]     [*[a b c] *[a d]]   
</pre></div></div>
<p>since d has to be a cell for <code>*[a d]</code> to evaluate.<span class="intersentencespace"></span> We really just want to
specify what happens when you replace an atomic operator with a cell.</p>
<p>What’s really cool about this rule is that, like the operators, it also chains:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 [46 47]] [[0 1] [3 0 1] [0 2]])
[[42 46 47] 0 42]
</pre></div></div>
<p>So if we wanted to produce our subject with all the atoms incremented, we could
do that:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 [46 47]] [[4 0 1] [4 0 2] [4 0 3]])
[43 47 48]
</pre></div></div>
<p>We can make our chains as long as we like</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 [46 47]] [[0 1] [3 0 1] [0 2] [3 0 2] [0 3] [3 0 3]])
[[42 46 47] 0 42 1 [46 47] 0]
</pre></div></div>
<p>That is, we can evaluate arbitrary numbers of formulas on the same subject in
parallel.</p>
<p>But what if we want to run them in series?</p>
<p>The expression <code>*[[42 43] [[4 0 3] 1 [0 1]]]</code> is a good example of how this might work:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 43] [[4 0 3] 1 [3 0 1]])
[44 [3 0 1]]
</pre></div></div>
<p>Wouldn’t it be interesting if we could run [44 [3 0 1]] through Nock again and end up with <code>*[44 [3 0 1]]</code> or just <code>1</code>?</p>
<p>We’d need a recursive operator to do that.<span class="intersentencespace"></span> Fortunately, we’ve got one, Nock 2:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 43] [2 [4 0 3] 1 [3 0 1]])
1
</pre></div></div>
<p>Obviously this is a toy example because we could just do the same thing
functionally with:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 43] [3 4 0 3])
1
</pre></div></div>
<p>But Nock 2 also lets us call a formula inside our subject.</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([[40 43] [4 0 1]] [2 [0 4] [0 3]])
41

~tomsyt-balsen/try=&gt; .*([[40 43] [4 0 1]] [2 [0 5] [0 3]])
44
</pre></div></div>
<p>Or we could completely separate the operator and arguments:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([[40 43] [0 1 3 4]] [2 [0 2] [0 31] [0 6] [0 30]])
44
</pre></div></div>
<p>We did a lot of slicing and dicing of nouns with the formula distribution rule.<span class="intersentencespace"></span> Nock 2 lets us run those reassembled nouns as expressions.<span class="intersentencespace"></span> We could think of
Nock 2 as being exactly like the distribution rule:</p>
<div class="code"><div class="highlight"><pre>*[a [b c] d]          [*[a b c] *[a d]]  
</pre></div></div>
<p>except that Nock 2 has an extra <code>*</code> meaning we run everything through Nock a
second time.<span class="intersentencespace"></span> So if we have two formulas</p>
<div class="code"><div class="highlight"><pre>*[subject 2 formula1 formula2]               *[*[subject formula1] *[subject formula2]]  
</pre></div></div>
<p>which we can rewrite as:</p>
<div class="code"><div class="highlight"><pre>*[a 2 b c]            *[*[a b] *[a c]] 
</pre></div></div>
<p>Let’s work through that last example again:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([[40 43] [0 1 3 4]] [2 [0 2] [0 31] [0 6] [0 30]])
44
</pre></div></div>
<p>So we’ve got our subject [[40 43] [0 1 3 4]] and a four different formulas:
[0 2] [0 31] [0 6] [0 30]</p>
<p>Let’s apply each of these to our subject separately:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([[40 43] [0 1 3 4]] [0 2])
[40 43]

~tomsyt-balsen/try=&gt; .*([[40 43] [0 1 3 4]] [0 31])
4

~tomsyt-balsen/try=&gt; .*([[40 43] [0 1 3 4]] [0 6])
0

~tomsyt-balsen/try=&gt; .*([[40 43] [0 1 3 4]] [0 30])
3
</pre></div></div>
<p>If instead of Nock 2, we had just used the formula distribution rule:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([[40 43] [0 1 3 4]] [[0 2] [0 31] [0 6] [0 30]])
[[40 43] 4 0 3]
</pre></div></div>
<p>But since Nock 2 is recursive:</p>
<div class="code"><div class="highlight"><pre>*[[[40 43] [0 1 3 4]] [2 [0 2] [0 31] [0 6] [0 30]]]
</pre></div></div>
<p>reduces to:</p>
<div class="code"><div class="highlight"><pre>*[[40 43] 4 0 3]
</pre></div></div>
<p>which is, of course, 43 + 1, or 44.</p>
<p>Now that we understand how to slice up nouns in our subject, let’s introduce Nock 5.</p>
<p>Nock 5 is exactly like Nock 3 and Nock 4 in structure, but we’ve saved it for
last because it’s easier to understand how to use it, once you know how to
distribute formulas.<span class="intersentencespace"></span> See if you can figure it out from the following:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 42] [5 [0 2] [0 3]])
0

~tomsyt-balsen/try=&gt; .*([42 43] [5 [0 2] [0 3]])
1

~tomsyt-balsen/try=&gt; .*([42 44] [5 [0 2] [0 3]])
1

~tomsyt-balsen/try=&gt; .*([[42 42] [42 42]] [5 [0 2] [0 3]])
0

~tomsyt-balsen/try=&gt; .*([[42 43] [42 43]] [5 [0 2] [0 3]])
0

~tomsyt-balsen/try=&gt; .*([[42 43] [42 43]] [5 [0 4] [0 3]])
1

~tomsyt-balsen/try=&gt; .*([[42 42] [42 42]] [5 [0 2] [0 3]])
0
</pre></div></div>
<p>Yes, Nock 5 is an equality test:</p>
<div class="code"><div class="highlight"><pre>*[a 5 b] 
</pre></div></div>
<p>if the head and the tail of the cell produced by <code>*[a b]</code> are the same, then
Nock 5 produces 0, if they are different, Nock 5 produces 1:</p>
<div class="code"><div class="highlight"><pre>*[a 5 b]              =(*[a b])
=([a a])              0 
=([a !a])              1
</pre></div></div>
<p>Where <code>!a</code> just means “not a.”</p>
<p>But what if <code>*[a b]</code> inside <code>=(*[a b])</code> produces an atom?</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([[42 42] [42 42]] [5 [1 1]])    
! exit
</pre></div></div>
<p>So we need to add</p>
<div class="code"><div class="highlight"><pre>=(atom)              ! exit
</pre></div></div>
<p>to our rule.</p>
<p>Let’s reduce the last example from above by hand:</p>
<div class="code"><div class="highlight"><pre>*[[[42 42] [42 42]] [5 [0 2] [0 3]]]

    *[a 5 b]                =(*[a b])

=(*[[[42 42] [42 42]] [0 2] [0 3]])

    *[a [b c] d]            [*[a b c] *[a d]] 

=([*[[[42 42] [42 42]] [0 2]] *[[[42 42] [42 42]] [0 3]]])

    *[a [0 b]]               /b of a

=([[42 42] *[[[42 42] [42 42]] [0 3]]])

    *[a [0 b]]               /b of a

=([[42 42] [42 42]])

    =([a a])                 0 

1
</pre></div></div>
<p>___</p>
<div id="uid22" data-tralics-id="uid22" class="subsection" data-number="3.5.1"><h3><a href="ch1_intro_to_nock_fragment.html#uid22" class="heading hyperref"><span class="number">3.5.1 </span>Summary:</a></h3>
<p><strong>Formula Distribution:</strong></p>
<p>A formula with a second formula at its head instead of an operator distributes the subject over both formulas:
</p><div class="code"><div class="highlight"><pre>*[a [b c] d]          [*[a b c] *[a d]]  
</pre></div></div>
<p><code>[b c]</code> is the first formula, d is the second formula.</p>
<p><strong>Nock 2</strong></p>
<div class="code"><div class="highlight"><pre>*[subject 2 formula-a formula]               *[*[subject formula1] *[subject formula2]]  
</pre></div></div>
<p>which translates to</p>
<div class="code"><div class="highlight"><pre>*[a 2 b c]            *[*[a b] *[a c]]
</pre></div></div>
<p><strong>Nock 5</strong>
</p><div class="code"><div class="highlight"><pre>*[a 5 b]              =(*[a b])
=([a a])              0 
=([a !a])              1
=(atom)               ! exit
</pre></div></div>
<p>___</p>
</div>
<div id="uid23" data-tralics-id="uid23" class="subsection" data-number="3.5.2"><h3><a href="ch1_intro_to_nock_fragment.html#uid23" class="heading hyperref"><span class="number">3.5.2 </span>Exercises:</a></h3>
<ol><li>Using the above rule, write a formula that reverses the order of the atoms in <code>[42 46 [68 69] 55]</code> i.e.<span class="intersentencespace"></span> produces <code>[55 [68 69] 46 42]</code>.<span class="intersentencespace"></span>
</li>
<li>Put the subject <code>[4 3 7 2 5 1 6]</code> in order from least to greatest.<span class="intersentencespace"></span>
</li>
<li>Does <code>*[[42 42] 5 [0 1] [0 3]]</code> produce a <code>yes</code> or a <code>no</code>?<span class="intersentencespace"></span>
</li>
<li>Write a noun that contains some data (nouns you find interesting) and some code (formulas you find interesting), write an expression with that noun as the subject that produces a single data-noun and a single code cell.<span class="intersentencespace"></span> Then use Nock 2 to apply the formula to the data.<span class="intersentencespace"></span>
</li>
<li>Choose a subject such that the following expression evaluates
</li></ol><div class="code"><div class="highlight"><pre>`~tomsyt-balsen/try=&gt; .*(subject [2 [0 5] [0 4] [0 3]])`
`43`
</pre></div></div>
</div></div>
<div id="cid9" data-tralics-id="cid9" class="section" data-number="3.6"><h2><a href="ch1_intro_to_nock_fragment.html#cid9" class="heading hyperref"><span class="number">3.6 </span>Section VI: Conclusion</a></h2>
<p>Let’s list out all the rules we’ve learned so far, with the explanations collapsed:</p>
<div class="code"><div class="highlight"><pre>A noun is an atom or a cell.  
An atom is a natural number.  
A cell is an ordered pair of nouns. 
 

[a b c]              [a [b c]]

?(cell)               0
?(atom)               1
+(cell)               ! exit
+(atom)               1 + atom
=([a a])              0 
=([a !a])              1
=(atom)               ! exit


*[a 0 b]              /b of a
*[a 1 b]              b 
*[a 2 b c]            *[*[a b] *[a c]]
*[a 3 b]              ?(*[a b])
*[a 4 b]              +(*[a b])
*[a 5 b]              =(*[a b])

*[a [b c] d]          [*[a b c] *[a d]] 
</pre></div></div>
<p>That looks cleaner.<span class="intersentencespace"></span> Now let’s look at an abridged version of the real Nock spec, which you should now be able to mostly read</p>
<div class="code"><div class="highlight"><pre>1  ::    A noun is an atom or a cell.
2  ::    An atom is a natural number.
3  ::    A cell is an ordered pair of nouns.
4  ::
5  ::    nock(a)          *a
6  ::    [a b c]          [a [b c]]
7  ::
8  ::    ?[a b]           0
9  ::    ?a               1
10 ::    +[a b]           +[a b]
11 ::    +a               1 + a
12 ::    =[a a]           0
13 ::    =[a b]           1
14 ::    =a               =a
15 ::
16 ::    /[1 a]           a
17 ::    /[2 a b]         a
18 ::    /[3 a b]         b
19 ::    /[(a + a) b]     /[2 /[a b]]
20 ::    /[(a + a + 1) b] /[3 /[a b]]
21 ::    /a               /a
22 ::
23 ::    *[a [b c] d]     [*[a b c] *[a d]]
24 ::
25 ::    *[a 0 b]         /[b a]
26 ::    *[a 1 b]         b
27 ::    *[a 2 b c]       *[*[a b] *[a c]]
28 ::    *[a 3 b]         ?*[a b]
29 ::    *[a 4 b]         +*[a b]
30 ::    *[a 5 b]         =*[a b]
31 ::
...
38 ::
39 ::    *a               *a
</pre></div></div>
<p>Since the Nock spec has been designed to be as concise as possible, a couple things are notationally different from the rules we’ve learned.</p>
<p>The largest difference is the block that defines what the <code>/</code> or axis operator does:</p>
<div class="code"><div class="highlight"><pre>16 ::    /[1 a]           a
17 ::    /[2 a b]         a
18 ::    /[3 a b]         b
19 ::    /[(a + a) b]     /[2 /[a b]]
20 ::    /[(a + a + 1) b] /[3 /[a b]]
</pre></div></div>
<p>This block of pseudocode is functionally equivalent to saying:</p>
<p>The head of axis /n is /(2n) and the tail of axis /n is /(2n+1).</p>
<p>If you read and understood Chapter 1, Section II, you understand what this is doing, even if you can’t parse its recursive structure.</p>
<p>The next most obvious difference is that between</p>
<div class="code"><div class="highlight"><pre>8  ::    ?[a b]           0
9  ::    ?a               1
10 ::    +[a b]           +[a b]
11 ::    +a               1 + a
12 ::    =[a a]           0
13 ::    =[a b]           1
14 ::    =a               =a
</pre></div></div>
<p>and</p>
<div class="code"><div class="highlight"><pre>?(cell)               0
?(atom)               1
+(cell)               ! exit
+(atom)               1 + atom
=([a a])              0 
=([a !a])             1
=(atom)               ! exit
</pre></div></div>
<p>We’ll work through the evolution of this block:</p>
<p>First thing is that since we’re trying to make the Nock specification small, we can get rid of the parentheses:</p>
<div class="code"><div class="highlight"><pre>?cell               0
?atom               1
+cell               ! exit
+atom               1 + atom
=[a a]              0 
=[a !a]             1
=atom               ! exit
</pre></div></div>
<p>Then we can remove the words ‘cell’ and ‘atom.’<span class="intersentencespace"></span> Since the rules in the nock spec match top to bottom, we can specify matching a rule to a cells or atom by putting [a b] above a.<span class="intersentencespace"></span> A cell will match [a b] and and atom will not, therefore because all cells will match [a b],
only atoms will match a below [a b].</p>
<div class="code"><div class="highlight"><pre>?[a b]             0
?a                 1
+[a b]             ! exit
+a                 1 + atom
=[a a]             0 
=[a !a]            1
=a                 ! exit
</pre></div></div>
<p>Next little thing we can do, along the same principle, is change !a to b, because [a b] below [a a] will only match to a pair of unequal nouns.</p>
<div class="code"><div class="highlight"><pre>?[a b]             0
?a                 1
+[a b]             ! exit
+a                 1 + atom
=[a a]             0 
=[a !a]            1
=a                 ! exit
</pre></div></div>
<p>Then there’s these lines, which we call our crash defaults:</p>
<div class="code"><div class="highlight"><pre>10 ::    +[a b]           +[a b]
14 ::    =a               =a
21 ::    /a               /a
39 ::    *a               *a
</pre></div></div>
<p>Basically the crash defaults determine when Nock needs to return an !<span class="intersentencespace"></span> exit, because something is nonsensical.<span class="intersentencespace"></span> In theory these lines imply that Nock spins forever in an infinite loop, in practice, Nock will just crash.</p>
<div class="code"><div class="highlight"><pre>10 ::    +[a b]           +[a b]
</pre></div></div>
<p>means that Nock crashes if you try to increment a cell</p>
<div class="code"><div class="highlight"><pre>14 ::    =a               =a
</pre></div></div>
<p>means that Nock crashes if you try run an equality test on an atom</p>
<div class="code"><div class="highlight"><pre>   21 ::    /a               /a
</pre></div></div>
<p>means that Nock crashes if you try to reference a noun axis that doesn’t exist</p>
<div class="code"><div class="highlight"><pre>39 ::    *a               *a
</pre></div></div>
<p>means that if you try to run something that’s not a valid formula (i.e.<span class="intersentencespace"></span> doesn’t match any of the preceding lines 1 through 38) through Nock, you guessed it, Nock crashes.</p>
<p>Replacing !<span class="intersentencespace"></span> exit in our rules with the appropriate crash default, we get the canoncial Nock specification:</p>
<div class="code"><div class="highlight"><pre>1  ::    A noun is an atom or a cell.
2  ::    An atom is a natural number.
3  ::    A cell is an ordered pair of nouns.
4  ::
5  ::    nock(a)          *a
6  ::    [a b c]          [a [b c]]
7  ::
8  ::    ?[a b]           0
9  ::    ?a               1
10 ::    +[a b]           +[a b]
11 ::    +a               1 + a
12 ::    =[a a]           0
13 ::    =[a b]           1
14 ::    =a               =a
15 ::
16 ::    /[1 a]           a
17 ::    /[2 a b]         a
18 ::    /[3 a b]         b
19 ::    /[(a + a) b]     /[2 /[a b]]
20 ::    /[(a + a + 1) b] /[3 /[a b]]
21 ::    /a               /a
22 ::
23 ::    *[a [b c] d]     [*[a b c] *[a d]]
24 ::
25 ::    *[a 0 b]         /[b a]
26 ::    *[a 1 b]         b
27 ::    *[a 2 b c]       *[*[a b] *[a c]]
28 ::    *[a 3 b]         ?*[a b]
29 ::    *[a 4 b]         +*[a b]
30 ::    *[a 5 b]         =*[a b]
31 ::
...
38 ::
39 ::    *a               *a
</pre></div></div>
<p>And that’s it!<span class="intersentencespace"></span> That’s really all there is to Nock.<span class="intersentencespace"></span> Everything else in Urbit, including the elided lines 32 through 38, is just a structure built on top of Nock.<span class="intersentencespace"></span> All your playing around in Urbit reduces to some combination of what you now already know.</p>
</div>
    </div>
  </body>
</html>
