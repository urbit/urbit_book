<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link href="stylesheets/pygments.css" media="screen" rel="stylesheet" type="text/css" />
    <link href="stylesheets/softcover.css" media="screen" rel="stylesheet" type="text/css" />
    <link href="stylesheets/custom.css" media="screen" rel="stylesheet" type="text/css" />
    
    <title>urbit_tutorial</title>
    
      <script type="text/x-mathjax-config">
              MathJax.Hub.Config({
        "HTML-CSS": {
          availableFonts: ["TeX"],
        },
        TeX: {
          extensions: ["AMSmath.js", "AMSsymbols.js"],
          equationNumbers: {
            autoNumber: "AMS",
            formatNumber: function (n) { return "3" + '.' + n }
          },
          Macros: {
            PolyTeX:    "Poly{\\TeX}",
            PolyTeXnic: "Poly{\\TeX}nic",
            sig: "\\textasciitilde",
ket: "\\verb+^+",
phep: "\\kode{-{}-}"
          }
        },
        showProcessingMessages: false,
        messageStyle: "none",
        imageFont: null
      });

      </script>
      <script type="text/javascript" src="MathJax/MathJax.js?config=TeX-AMS-MML_SVG"></script>
    
  </head>
  <body>
    
    <div id="book">
      <div id="cid3" data-tralics-id="cid3" class="chapter" data-number="3" data-chapter="ch1_intro_to_nock"><h1><a href="ch1_intro_to_nock_fragment.html#cid3" class="heading hyperref"><span class="number">Chapter 3 </span>Introductory Nock</a></h1>
<blockquote class="quotation"><p class="noindent"><em>What one fool can do, another can.</em></p>
<p style="margin-top: 6.0pt"><span class="break"></span></p>
<p class="noindent">—<strong>Ancient Simian proverb</strong></p>
</blockquote><p>Think of Nock as a kind of functional assembly language.<span class="intersentencespace"></span> It’s not like
assembly language in that it’s directly executed by the hardware.<span class="intersentencespace"></span> It is like
assembly language in that (a) everything in Urbit executes as Nock; (b) you
wouldn’t want to program directly in Nock; and (c) learning to program directly
in Nock is a great way to start understanding Urbit from the ground up.</p>
<p>Just as Unix runs C programs by compiling them to assembler, Urbit runs Hoon
programs by compiling them to Nock.<span class="intersentencespace"></span> You could try to learn Hoon without
learning Nock.<span class="intersentencespace"></span> But just as C is a thin wrapper over the physical CPU, Hoon is
a thin wrapper over the Nock virtual machine.<span class="intersentencespace"></span> It’s a tall stack made of thin
layers, which is much easier to learn a layer at a time.</p>
<p>And unlike most fundamental theories of computing, there’s really nothing smart
or interesting about Nock.<span class="intersentencespace"></span> Of course, in a strictly formal sense, all of
computing is math.<span class="intersentencespace"></span> But that doesn’t mean it needs to feel like math.<span class="intersentencespace"></span> Nock is
a simple mechanical device and it’s meant to feel that way.</p>
<p>Let’s get start by learning how to use Urbit’s operating system, Arvo, to
evaluate Nock code.</p>
</div>
<div id="sec-getting_started" data-tralics-id="cid4" class="section" data-number="3.1"><h2><a href="ch1_intro_to_nock_fragment.html#sec-getting_started" class="heading hyperref"><span class="number">3.1 </span>Getting Started</a></h2>
<p>We’ll assume that you’ve gone through the Urbit setup process and have an Arvo
prompt that looks something like this:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt;
</pre></div></div>
<p>At your prompt, type the following exactly:
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(42 [0 1])
</pre></div></div>
<p>This should return <code>42</code>.<span class="intersentencespace"></span> Don’t worry about what this is doing yet.</p>
<p>It’s very important that you actually go to your prompt and type in our
examples.<span class="intersentencespace"></span> Copying and pasting is cheating, although using your up-arrow is not.<span class="intersentencespace"></span> This might seem silly, but to learn
Nock (or any language) it’s very important that your fingers get
comfortable writing it.</p>
<p>If you accidentally make a mistake typing in a Nock expression, you’ll get a
syntax error:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(42[0 1])
~ &lt;syntax error at [1 6]&gt;

~tomsyt-balsen/try=&gt; .*( 42 [0 1])
~ &lt;syntax error at [1 4]&gt;
</pre></div></div>
<p>The easiest way to get a syntax error is to accidentally leave out a space or add
an extra one.<span class="intersentencespace"></span> Fortunately, the error message tells you where the mistake is; for example, the output</p>
<div class="code"><div class="highlight"><pre>~ &lt;syntax error at [1 4]&gt;
</pre></div></div>
<p>means that there’s an error at <code>line 1</code>, <code>column 4</code>.<span class="intersentencespace"></span> Once you know where an
error is, it’s much easier to fix.</p>
<p>But even if your Nock expression is formatted correctly, you might get
something that looks like this:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(42 [5 0 1])
! exit
</pre></div></div>
<p>This means that the expression you typed in is correct Nock, but it just
doesn’t produce anything.<span class="intersentencespace"></span> Unfortunately, we can’t give you line and column
numbers on this one, so the only surefire way to debug an exit message is to
understand what your code is doing.<span class="intersentencespace"></span> Literally speaking, an exit message means
you tried to do something that just doesn’t make sense, such as trying to
reference data that doesn’t exist, or trying to increment something that’s not
a number, or asking if <code>42</code> is equal without asking what it’s equal to.</p>
<p>Enough about errors, let’s practice some expressions that work:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(41 [0 1])
41

~tomsyt-balsen/try=&gt; .*(40 [0 1])
40

~tomsyt-balsen/try=&gt; .*(374 [0 1])
374
</pre></div></div>
<p>The perceptive reader will notice the pattern here: If a is a number, <code>.*(a [0 1])</code> always produces <code>a</code>.<span class="intersentencespace"></span> To test it, run the following, but
replace <code>a</code> with any number you like.</p>
<div class="code"><div class="highlight"><pre>.*(a [0 1])
a
</pre></div></div>
<p>Once you’re satisfied that this is true, let’s do something slightly
different:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(374 [1 0])
0

~tomsyt-balsen/try=&gt; .*(40 [1 0])
0

~tomsyt-balsen/try=&gt; .*(41 [1 0])
0
</pre></div></div>
<p>This pattern is pretty easy: <code>*(a [1 0])</code> always produces <code>0</code>, no matter what a
is.</p>
<p>Again, play around with the above yourself by choosing your own values for a:</p>
<div class="code"><div class="highlight"><pre>.*(a [1 0])
0
</pre></div></div>
<p>One more pattern, and then we’ll actually explain what these numbers and brackets represent:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(374 [1 374])
374

~tomsyt-balsen/try=&gt; .*(40 [1 374])
374

~tomsyt-balsen/try=&gt; .*(374 [1 40])
40
</pre></div></div>
<p>As an exercise, run the last three lines again but replace <code>374</code> and <code>40</code> with
numbers of your own.</p>
<p>You’ve probably already guessed the pattern here: <code>.*(a [1 b])</code> always produces
<code>b</code>, regardless of <code>a</code>.<span class="intersentencespace"></span> But feel free to test it, replacing <code>a</code> and <code>b</code> with any number.</p>
<div class="code"><div class="highlight"><pre>.*(a [1 b])
b
</pre></div></div>
<p>Let’s run the following piece of code again:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(42 [0 1])
</pre></div></div>
<p>Nock is made up of two basic building blocks: atoms, which can be any
non-negative whole number, and cells, which are pairs of numbers or cells
(cells can go inside of other cells.)<span class="intersentencespace"></span> <code>42</code>, for example, is an atom.<span class="intersentencespace"></span> <code>[0 1]</code> is
a cell.<span class="intersentencespace"></span> Even <code>[42 [0 1]]</code> is a cell.<span class="intersentencespace"></span> (It’s very important to note that cells
can nest inside other cells.)</p>
<p>Collectively, both atoms and cells are called nouns.<span class="intersentencespace"></span> And Nock is just a list of
rules (or a set of patterns) for transforming nouns.<span class="intersentencespace"></span> You put one noun in, you
get another noun out.<span class="intersentencespace"></span> It’s like algebra: <span class="inline_math">\(  f(x) = y  \)</span>, <code>nock(noun_a) = noun_b</code></p>
<p>The atom <code>42</code> is a noun, the cell <code>[0 1]</code> is a noun and in fact <code>.*(42 [0 1])</code>
is a noun too, except that it’s wrapped in syntax that tells Arvo “run
this noun through Nock”.<span class="intersentencespace"></span> (The notation <code>.*(42 [0 1])</code> is actually the way to tell Arvo
(Urbit’s operating system) to evaluate <code>Nock([42 [0 1]])</code>.)<span class="intersentencespace"></span> The cellular noun
<code>[42 [0 1]]</code> goes into Nock, the atomic noun <code>42</code> comes out.</p>
<p>We could simply write our very first example again as</p>
<div class="code"><div class="highlight"><pre>nock([42 [0 1]]) = 42
</pre></div></div>
<p>except that we wouldn’t be able to evaluate it in Arvo.</p>
<p>Actually, we almost never use the above mathematical notation.<span class="intersentencespace"></span> For the sake of
brevity we almost always write <code>nock(a)</code> using the notation <code>*a</code>.<span class="intersentencespace"></span> Thus, <code>nock([42 [0 1]])</code> and <code>*[42 [0 1]]</code> mean the same thing.<span class="intersentencespace"></span> If we want to tell Arvo to evaluate
the noun, we use <code>.*(42 [0 1])</code>.<span class="intersentencespace"></span> You will notice that the outermost brackets
somewhat confusingly disappear when we use the <code>.*()</code> function in Arvo; we will
explain why in <a href="#cha-dont_know" class="hyperref">Chapter <span class="undefined_ref">cha:dont_know</span></a>.</p>
<p>In documenting Nock, we most frequently use the <code>*[42 [0 1]]</code> style of
notation.<span class="intersentencespace"></span> Instead of, for example, writing</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(a [1 b])
b
</pre></div></div>
<p>the standard way of writing out the rules of Nock is</p>
<div class="code"><div class="highlight"><pre>*[a [1 b]]                  b
</pre></div></div>
<p>with the left hand side being the noun that matches our input and the right
side being the product of that input.</p>
<p>We’ve been using <code>a</code> and <code>b</code> as variables that represent numbers (i.e., atoms),
but we can and do use them more broadly to represent nouns in general.</p>
<p>Let’s apply the rule</p>
<div class="code"><div class="highlight"><pre>*[a [1 b]]                  b
</pre></div></div>
<p>which, to reiterate, means that when we run any noun of the form <code>[a [1 b]]</code>
through Nock (using the expression <code>.*(a [1 b])</code> in Arvo) always produces <code>b</code>,
regardless of <code>a</code>.</p>
<p>Let’s run a few examples:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(301 [1 374])
374

~tomsyt-balsen/try=&gt; .*([42 43] [1 312])
312

~tomsyt-balsen/try=&gt; .*(374 [1 [44 48]])
[42 43]

~tomsyt-balsen/try=&gt; .*([46 49] [1 [456 539]])
[456 539]

~tomsyt-balsen/try=&gt; .*(374 [1 [[[32 34] 33]]])
[[[31 32] 33]
</pre></div></div>
<div id="sec-getting_started_summary" data-tralics-id="uid1" class="subsection" data-number="3.1.1"><h3><a href="ch1_intro_to_nock_fragment.html#sec-getting_started_summary" class="heading hyperref"><span class="number">3.1.1 </span>Summary</a></h3>
<p>To conclude this section, let’s review what we’ve learned:</p>
<p><strong>Notation:</strong></p>
<p>Arvo syntax:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(42 [0 1])
42
</pre></div></div>
<p>Math notation:</p>
<div class="code"><div class="highlight"><pre>nock([42 [0 1]]) = 42
</pre></div></div>
<p>Nock notation:</p>
<div class="code"><div class="highlight"><pre>*[42 [0 1]]                  42
</pre></div></div>
<p><strong>Error Messages:</strong></p>
<p>A syntax error occurs when an expression in Arvo is not typed in correctly.</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*( 42 [0 1])
~ &lt;syntax error at [1 4]&gt;
</pre></div></div>
<p>The cell in the syntax error gives the line and column number of the location of the error.</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(42 [5 0 2])
! exit
</pre></div></div>
<p><strong>Structures:</strong></p>
<p>A noun is an atom or a cell.<span class="intersentencespace"></span> An atom is a natural number.<span class="intersentencespace"></span> A cell is an
ordered pair of two nouns, i.e., two atoms, two cells, or a cell and an atom.</p>
<p><strong>Nock Rules</strong></p>
<p>Lower-case letters such as <code>a</code> or <code>b</code> are variables that represent nouns.</p>
<p>Nock rules are notated with two columns, where the left hand side indicates
what pattern the noun matches, and the right hand side indicates what the noun
produces.<span class="intersentencespace"></span> </p><div class="code"><div class="highlight"><pre>*[a [0 1]]                  a
*[a [1 b]]                  b
</pre></div></div>
</div>
<div id="uid2" data-tralics-id="uid2" class="subsection" data-number="3.1.2"><h3><a href="ch1_intro_to_nock_fragment.html#uid2" class="heading hyperref"><span class="number">3.1.2 </span>Exercises</a></h3>
<ol><li>Using the rule:
<p><code>text
*[a [0 1]] a
</code></p>
<p>replace <code>a</code> with an atom, a cell, and multiple cells, and return them all respectively in Arvo (using, of course, the proper Arvo syntax).</p>
</li>
<li>Using the rule:
<p><code>text
*[a [1 b]] b
</code>
Write a cell, substituting a noun of more then 4 cells for <code>b</code>, and any atom for <code>a</code>, and then return it in Arvo (again, in the correct syntax, of course).<span class="intersentencespace"></span> Then play around with what you substitute for a: change it to a different atom, make it a cell, and then a set of nested cells.<span class="intersentencespace"></span> Does it make a difference?<span class="intersentencespace"></span> If yes, why?<span class="intersentencespace"></span> If not, why not?<span class="intersentencespace"></span></p>
</li>
<li>Produce a syntax error that reads:
<div class="code"><div class="highlight"><pre>~ &lt;syntax error at [1 14]&gt;
</pre></div></div>
</li>
<li>With pen and paper, write out all three possible forms of notation (Arvo syntax, Math notation, and Nock notation) for each
of the expressions you evaluated in exercises 1.<span class="intersentencespace"></span> and 2.<span class="intersentencespace"></span>
</li></ol></div></div>
<div id="sec-noun_structure" data-tralics-id="cid5" class="section" data-number="3.2"><h2><a href="ch1_intro_to_nock_fragment.html#sec-noun_structure" class="heading hyperref"><span class="number">3.2 </span>Noun Structure</a></h2>
<p>In <a href="ch1_intro_to_nock_fragment.html#sec-getting_started" class="hyperref">Section <span class="ref">3.1</span></a> we played around with this:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(42 [0 1])
42
</pre></div></div>
<p>which corresponds to the pattern
</p><div class="code"><div class="highlight"><pre>*[a [0 1]]                  a
</pre></div></div>
<p>Now we’re going to experiment with what happens when we replace <code>1</code> with
different values, as seen in <a href="ch1_intro_to_nock_fragment.html#code-several_nock_formulas" class="hyperref">Listing <span class="ref">3.1</span></a>.<span class="intersentencespace"></span> (Remember, as you follow along, type out the examples at your own Arvo prompt.)</p>
<div class="codelisting" id="code-several_nock_formulas" data-tralics-id="uid7" data-number="3.1"><div class="heading"><span class="number">Listing 3.1:</span> 

<span class="description">Applying different formulas to the same argument.</span>
</div>

<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 43] [0 1])
[42 43]

~tomsyt-balsen/try=&gt; .*([42 43] [0 2])
42

~tomsyt-balsen/try=&gt; .*([42 43] [0 3])
43

~tomsyt-balsen/try=&gt; .*([42 43] [0 4])
! exit
</pre></div></div></div><p>We don’t really have enough examples in <a href="ch1_intro_to_nock_fragment.html#code-several_nock_formulas" class="hyperref">Listing <span class="ref">3.1</span></a> to figure out the pattern yet.<span class="intersentencespace"></span> Let’s
change <code>[42 43]</code> to <code>[[44 45] 43]</code> and try some more.<span class="intersentencespace"></span> </p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([[44 45] 43] [0 1])
[[44 45] 43]

~tomsyt-balsen/try=&gt; .*([[44 45] 43] [0 2])
[44 45]

~tomsyt-balsen/try=&gt; .*([[44 45] 43] [0 3])
43

~tomsyt-balsen/try=&gt; .*([[44 45] 43] [0 4])
44

~tomsyt-balsen/try=&gt; .*([[44 45] 43] [0 5])
45

~tomsyt-balsen/try=&gt; .*([[44 45] 43] [0 6])
! exit
</pre></div></div>
<p>It looks like anything of the form <code>*[a [0 b]]</code> produces the sub-nouns that are inside of <code>a</code>.<span class="intersentencespace"></span> Remember that <code>*[a [0 b]]</code> is the same as <code>.*(a [0 b])</code>, e.g., <code>a</code> is <code>[[44 45] 43]</code> and <code>b</code> is one of the atoms <code>1</code> through <code>6</code>.</p>
<p>But how does <code>*[a [0 b]]</code> know which pieces of <code>a</code> to choose?</p>
<p>Let’s do one more example and then we’ll explain it.<span class="intersentencespace"></span> </p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 [46 47]] [0 1])
[42 [46 47]]

~tomsyt-balsen/try=&gt; .*([42 [46 47]] [0 2])
42

~tomsyt-balsen/try=&gt; .*([42 [46 47]] [0 3])
[46 47]

~tomsyt-balsen/try=&gt; .*([42 [46 47]] [0 4])
! exit

~tomsyt-balsen/try=&gt; .*([42 [46 47]] [0 5])
! exit

~tomsyt-balsen/try=&gt; .*([42 [46 47]] [0 6])
46

~tomsyt-balsen/try=&gt; .*([42 [46 47]] [0 7])
47
</pre></div></div>
<p>Try to solve this puzzle on your own by playing with the following:
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(a [0 b])
</pre></div></div>
<p>where <code>a</code> is a cell and <code>b</code> is an atom.<span class="intersentencespace"></span> Try to pick atoms for <code>b</code> that are
small and try to pick cells for <code>a</code> that have lots of nesting.</p>
<p>When you’re ready to have things explained to you, read on.</p>
<p>Think of a noun as a tree structure:
</p><div class="code"><div class="highlight"><pre>  [42 [46 47]]
  /       \
42      [46 47]]
          / \
        46   47
</pre></div></div>
<p>Every cell has two branches (the head of the cell and the tail) leading down
from it.<span class="intersentencespace"></span> Atoms have no branches, because they can’t be broken down any further
(which is why they’re called atoms—from the Greek <em><span class="unicode">ἄτομος</span></em>, “indivisible”).</p>
<p>Let’s look at the tree of the other noun we played with, <code>[[44 45] 43]</code>:
</p><div class="code"><div class="highlight"><pre> [[44 45] 43]
    /      \
[44 45]    43
 /   \
44   45
</pre></div></div>
<p>It should be pretty obvious that we could change the values of any of the atoms
in the tree without changing the structure of the tree.<span class="intersentencespace"></span> That is to say, <code>[[44
45] 43]</code> and <code>[[24 25] 23]</code> have the same tree structure:
</p><div class="code"><div class="highlight"><pre> [[22 25] 23]
    /      \
[22 25]    23
 /   \
22   25
</pre></div></div>
<p>And now, for a more complicated tree, here’s the noun <code>[[[48 49] 45] [46 47]]</code>:
</p><div class="code"><div class="highlight"><pre>  [[[48 49] 45] [46 47]]
       /            \
 [[48 49] 45]      [46 47]
   /       \        /   \
[48 49]    45      46   47
 /   \
48   49
</pre></div></div>
<p>So how do the above trees relate to running <code>.*(a [0 b])</code>?<span class="intersentencespace"></span> Every part
of the tree gets mapped to an atomic address, called an <em>axis</em>.<span class="intersentencespace"></span> The mapping
looks something like this:
</p><div class="code"><div class="highlight"><pre>           1
       /       \
     2           3
   /   \       /   \
  4     5     6     7
 / \   / \   / \   / \
8   9 10 11 12 13 14 15
</pre></div></div>
<p>Or, because the lines are kind of ugly:
</p><div class="code"><div class="highlight"><pre>         1
    2          3
 4    5     6     7
8 9 10 11 12 13 14 15
</pre></div></div>
<p>Of course, this only a very small part of the entire tree.<span class="intersentencespace"></span> We extend the tree
by applying the rule: Every axis <code>/n</code> has a head with the axis<code>/2n</code> and a tail
with the axis <code>/2n+1</code>.<span class="intersentencespace"></span> +++recast &amp; expand [MDH]+++</p>
<p>+++Is <code>/n</code> read “slash n”?+++</p>
<p>We map from noun to axis by comparing the tree of the noun with the axis tree
and seeing what matches.<span class="intersentencespace"></span> Like so, marking axes with a <code>/</code> character:
</p><div class="code"><div class="highlight"><pre>  /1 : [[44 45] 43]
         /        \
 /2 : [44 45]     43 : /3
      /     \
/4 : 44      45 : /5
</pre></div></div>
<p>Again, because it bears repeating: the head of axis <code>/n</code> is <code>/2n</code> and the tail
of axis <code>/n</code> is <code>/2n+1</code>.<span class="intersentencespace"></span> Remember that the head is the left-hand noun and the
tail the right-hand noun of a cell-pair.</p>
<p>Start with 1.<span class="intersentencespace"></span> This is your root axis.<span class="intersentencespace"></span> All nouns have a valid axis <code>/1</code>, even
atoms.<span class="intersentencespace"></span> and the axis <code>/1</code> just refers to the noun itself.<span class="intersentencespace"></span> In the above example,
axis /1 of <code>[[44 45] 43]</code> is just <code>[[44 45] 43]</code>.<span class="intersentencespace"></span> The head of <code>[[44 45] 43]</code> is
<code>[44 45]</code> and the tail is <code>43</code>.<span class="intersentencespace"></span> Thus, axis <code>/2</code> of <code>[[44 45] 43]</code> is <code>[44 45]</code>
and axis /3 is <code>43</code>.</p>
<p>Another way to think about it is that the tree map has layers:
</p><div class="code"><div class="highlight"><pre>layer 0             1
layer 1        2          3
layer 2     4    5     6     7
layer 3    8 9 10 11 12 13 14 15
</pre></div></div>
<p>which correspond to the nesting depth of the noun.<span class="intersentencespace"></span> If a noun is inside two
cells, like <code>46</code> inside <code>[[[48 49] 45] [46 47]]</code> then its axis is at layer 2 of
the tree.<span class="intersentencespace"></span> If its inside three cells like <code>48</code>, then its axis is at layer
three.</p>
<p>Recall the pattern we learned in <a href="ch1_intro_to_nock_fragment.html#sec-getting_started_summary" class="hyperref">Section <span class="ref">3.1.1</span></a>:
</p><div class="code"><div class="highlight"><pre>*[a [0 1]]                  a
</pre></div></div>
<p>This, we now see, is a special case of
</p><div class="code"><div class="highlight"><pre>*[a [0 b]]              axis /b of a
</pre></div></div>
<p>The 0 in <code>*[a [0 b]]</code> is just an operator that means “axis”.<span class="intersentencespace"></span> Nock maps simple
operators and functions to atoms, instead of a character like <code>/</code> for example,
because atoms (and cells) are all Nock knows.<span class="intersentencespace"></span> Fortunately for us,
there are only eleven atoms that are operators, atoms <code>0</code> through <code>10.</code></p>
<div id="uid8" data-tralics-id="uid8" class="subsection" data-number="3.2.1"><h3><a href="ch1_intro_to_nock_fragment.html#uid8" class="heading hyperref"><span class="number">3.2.1 </span>Summary</a></h3>
<p><strong>Noun structure:</strong></p>
<p>Nouns are trees that look like this:
</p><div class="code"><div class="highlight"><pre> [[44 45] 43]
    /      \
[44 45]    43
 /   \
44   45
</pre></div></div>
<p>The left-hand of a cell is called the head.<span class="intersentencespace"></span> The right hand is the tail.</p>
<p><strong>Axes:</strong></p>
<p>An axis is the address of a node of the noun tree.</p>
<p>The notation for axis <span class="inline_math">\( n \)</span> is <code>/n</code>.</p>
<p>The first part of the axis tree looks like this:
</p><div class="code"><div class="highlight"><pre>         1
    2          3
 4    5     6     7
8 9 10 11 12 13 14 15
</pre></div></div>
<p>The head of axis <code>/n</code> is <code>/2n</code> and the tail of axis <code>/n</code> is <code>/(2n+1)</code>.</p>
<p><strong>Nock Operators:</strong></p>
<p>The operators in Nock are functions mapped onto the eleven atoms <code>0</code> through <code>10</code>.</p>
<p><strong>Nock 0:</strong></p>
<p>The Nock operator that produces a given axis of a noun:
</p><div class="code"><div class="highlight"><pre>*[a [0 b]]               /b of a
</pre></div></div>
</div>
<div id="uid9" data-tralics-id="uid9" class="subsection" data-number="3.2.2"><h3><a href="ch1_intro_to_nock_fragment.html#uid9" class="heading hyperref"><span class="number">3.2.2 </span>Exercises</a></h3>
<ol><li>Take pen and paper and map out the axes of
<div class="code"><div class="highlight"><pre>   [[[48 49] 45] [46 47]]
       /             \
 [[48 49] 45]      [46 47]
   /       \        /   \
[48 49]    45      46   47
 /   \
48   49
</pre></div></div>
<p>then to test yourself, run:
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([[[48 49] 45] [46 47]] [0 b])
</pre></div></div>
<p>for each axis <code>/b</code> of <code>[[[48 49] 45] [46 47]]</code></p>
</li>
<li>Write a noun <code>a</code> such that the following produces something:
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(a [0 100])
</pre></div></div>
<p>In other words, find a noun that has an axis <code>/100</code>.<span class="intersentencespace"></span></p>
</li>
<li>Prune your noun from the last exercise so that it’s as short as possible,
while still having an axis <code>/100</code>.<span class="intersentencespace"></span>
</li>
<li>If you still feel confused, replicate the previous two exercises with the
axes <code>/7</code>, <code>/17</code>, <code>/27</code>, <code>/47</code> and <code>/87</code>.<span class="intersentencespace"></span>
</li>
<li>Build a noun that has every atom set to its own axis.<span class="intersentencespace"></span> The bigger the noun
the better.<span class="intersentencespace"></span> I’ll get you started:
<div class="code"><div class="highlight"><pre>1
[2 3]
[[4 5] 3]
[[4 5] [6 7]
</pre></div></div>
<p>To test different atoms in your noun, run
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(a [0 b])
</pre></div></div>
</li></ol></div></div>
<div id="sec-nock_3" data-tralics-id="cid6" class="section" data-number="3.3"><h2><a href="ch1_intro_to_nock_fragment.html#sec-nock_3" class="heading hyperref"><span class="number">3.3 </span>Nock 3</a></h2>
<p>In the last section we learned how to access data inside nouns.<span class="intersentencespace"></span> Now we’re going
to learn what you can do with data.<span class="intersentencespace"></span> After all, Nock is a computer, so you
should be able to, you know, compute things.</p>
<p>We mentioned in the last section that Nock has eleven operators, <code>0</code> through
<code>10</code>.<span class="intersentencespace"></span> We saw <code>Nock 1</code> in <a href="ch1_intro_to_nock_fragment.html#sec-getting_started" class="hyperref">Section <span class="ref">3.1</span></a>:
</p><div class="code"><div class="highlight"><pre>*[a [1 b]]                  b
</pre></div></div>
<p>We could describe <code>Nock 1</code> the constant operator, since it always produces <code>b</code>
no matter what you put in as <code>a</code>.</p>
<p>We also have <code>Nock 0</code>, which lets you refer to the sub-noun at the <code>axis b</code> of
your subject <code>a</code>.<span class="intersentencespace"></span> </p><div class="code"><div class="highlight"><pre>*[a [0 b]]               /b of a
</pre></div></div>
<p>We’re going to skip <code>Nock 2</code> and cover it in <a href="ch1_intro_to_nock_fragment.html#sec-nock_5_nock_2" class="hyperref">Section <span class="ref">3.5</span></a> and for now just jump
straight to <code>Nock 3</code>.</p>
<p>Before we do, let’s quickly go over three new terms that’ll help us talk about
operators:</p>
<p>Let’s say you have the Nock expression
</p><div class="code"><div class="highlight"><pre>*[a [1 b]]
</pre></div></div>
<p>We know that <code>1</code> is the operator, but shouldn’t we have names for what <code>a</code> and
<code>b</code> are?</p>
<p>Let’s call <code>a</code> the <em>subject</em>, because it’s being subjected to our computation.<span class="intersentencespace"></span> (Poor <code>a</code>.)</p>
<p>We’ll call <code>b</code> an <em>argument</em>, and we’ll call the cell <code>[1 b]</code> a <em>formula</em>.<span class="intersentencespace"></span> Diagramming it out:
</p><div class="code"><div class="highlight"><pre>*[a [1 b]]
*[subject [operator argument]]
*[subject formula]
</pre></div></div>
<p>Good, now that we’ve got vocab out of the way, let’s get cooking.</p>
<p>Let’s use the big noun <code>[[[48 49] 45] [46 47]]</code> from <a href="ch1_intro_to_nock_fragment.html#sec-noun_structure" class="hyperref">Section <span class="ref">3.2</span></a> as our subject.<span class="intersentencespace"></span> </p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([[[48 49] 45] [46 47]] [3 0])
! exit
</pre></div></div>
<p>Uh-oh, Arvo is telling us we just tried to do something indecent and unnatural.<span class="intersentencespace"></span> </p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([[[48 49] 45] [46 47]] [3 1])
! exit

~tomsyt-balsen/try=&gt; .*([[[48 49] 45] [46 47]] [3 2])
! exit

~tomsyt-balsen/try=&gt; .*([[[48 49] 45] [46 47]] [3 3])
! exit

~tomsyt-balsen/try=&gt; .*([[[48 49] 45] [46 47]] [3 4])
! exit
</pre></div></div>
<p>Looks like <code>Nock 3</code> doesn’t like an atomic argument.<span class="intersentencespace"></span> Let’s go cellular.<span class="intersentencespace"></span> </p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([[[48 49] 45] [46 47]] [3 [0 1]])
0
</pre></div></div>
<p>Okay, so at least that does something.</p>
<p>Let’s try some more:
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([[[48 49] 45] [46 47]] [3 [0 2]])
0

~tomsyt-balsen/try=&gt; .*([[[48 49] 45] [46 47]] [3 [0 3]])
0

~tomsyt-balsen/try=&gt; .*([[[48 49] 45] [46 47]] [3 [0 4]])
0

~tomsyt-balsen/try=&gt; .*([[[48 49] 45] [46 47]] [3 [0 5]])
1
</pre></div></div>
<p>Wait, what?</p>
<p>Hold on, aren’t <code>[0 1]</code> or <code>[0 5]</code> valid Nock formulas on their own?<span class="intersentencespace"></span> If <code>3</code>
only takes cells, and formulas are cells, maybe it matters what the formula
does on its own.</p>
<p>Let’s try that sequence again without <code>Nock 3</code>:
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([[[48 49] 45] [46 47]] [0 1])
[[[48 49] 45] [46 47]]

~tomsyt-balsen/try=&gt; .*([[[48 49] 45] [46 47]] [0 2])
[[48 49] 45]

~tomsyt-balsen/try=&gt; .*([[[48 49] 45] [46 47]] [0 3])
[46 47]

~tomsyt-balsen/try=&gt; .*([[[48 49] 45] [46 47]] [0 4])
[48 49]

~tomsyt-balsen/try=&gt; .*([[[48 49] 45] [46 47]] [0 5])
45
</pre></div></div>
<p>One of these things is not like the others.<span class="intersentencespace"></span> Looks like something changes
whether the formula <code>[0 n]</code> refers to an atom or a cell in our subject.</p>
<p>Let’s see what happens if we run Nock 3 with <code>[0 1]</code> as its argument and try
some different subjects:
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 42] [3 [0 1]])
0

~tomsyt-balsen/try=&gt; .*(42 [3 [0 1]])
1

~tomsyt-balsen/try=&gt; .*([1 1] [3 [0 1]])
0

~tomsyt-balsen/try=&gt; .*(1 [3 [0 1]])
1
</pre></div></div>
<p>Looks like that’s <code>0</code> for cells and <code>1</code> for atoms.<span class="intersentencespace"></span> Which means that <code>Nock 3</code> is
cell/atom tester.</p>
<p>How’s that work?</p>
<p><code>Nock 3</code>’s argument is itself a formula.<span class="intersentencespace"></span> Let’s call it <code>b</code>.<span class="intersentencespace"></span> </p><div class="code"><div class="highlight"><pre>*[subject-a [3 formula-b]]
</pre></div></div>
<p><code>Nock 3</code> produces either a <code>0</code> or a <code>1</code>, depending on what formula-b does when
applied to subject-a:
</p><div class="code"><div class="highlight"><pre>*[subject-a formula-b]
</pre></div></div>
<p>Or more simply:
</p><div class="code"><div class="highlight"><pre>*[a b]
</pre></div></div>
<p>If <code>*[a b]</code> produces a cell, then <code>*[a [3 b]]</code> produces 0.<span class="intersentencespace"></span> If <code>*[a b]</code> produces
an atom, <code>*[a [3 b]]</code> produces 1.<span class="intersentencespace"></span> So our pattern for Nock 3 is:
</p><div class="code"><div class="highlight"><pre>*[a [3 b]]         ?(*[a b])
?(cell)            0
?(atom)            1
</pre></div></div>
<p><code>?(x)</code> is just a little functional notation so that we can write out both possible branches.</p>
<p>We should also note that Urbit uses the atom <code>0</code> to mean “yes” and the atom <code>1</code>
to mean “no.”<span class="intersentencespace"></span> (This may seem different and annoying, but it’s
the same thing that Unix does.)</p>
<p>In that context, <code>Nock 3</code> is just asking the question “When the argument is applied to the subject, is the result a cell?”</p>
<div id="uid15" data-tralics-id="uid15" class="subsection" data-number="3.3.1"><h3><a href="ch1_intro_to_nock_fragment.html#uid15" class="heading hyperref"><span class="number">3.3.1 </span>Summary</a></h3>
<p><strong>Vocabulary</strong></p>
<ul><li>The <strong>subject</strong> is the noun that gets computed.<span class="intersentencespace"></span>
</li>
<li>The <strong>operator</strong> is an atom that tells us how to Nock the subject and arguments.<span class="intersentencespace"></span>
</li>
<li>The <strong>arguments</strong> modify the behavior of the operator.<span class="intersentencespace"></span>
</li>
<li>A <strong>formula</strong> is a cell of <code>[operator arguments]</code>
</li></ul><p>These can be summarized as follows:</p>
<div class="code"><div class="highlight"><pre>*[a [1 b]]
*[subject [operator arguments]]
*[subject formula]
</pre></div></div>
<p><strong>Yes and No</strong></p>
<p>Atom <code>0</code> means “yes”
Atom <code>1</code> means “no.”</p>
<p><strong>Nock 3</strong></p>
<p><code>Nock 3</code> is a cell tester.<span class="intersentencespace"></span> </p><div class="code"><div class="highlight"><pre>*[a [3 b]]         ?(*[a b])
?(cell)            0
?(atom)            1
</pre></div></div>
</div>
<div id="uid20" data-tralics-id="uid20" class="subsection" data-number="3.3.2"><h3><a href="ch1_intro_to_nock_fragment.html#uid20" class="heading hyperref"><span class="number">3.3.2 </span>Exercises</a></h3>
<ol><li>Run and compare
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(a b)
</pre></div></div>
<p>and +++add a listing and a listing reference [MDH]+++
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(a [3 b])
</pre></div></div>
<p>with different values for <code>a</code> and <code>b</code>.<span class="intersentencespace"></span> +++add a listing and a listing reference [MDH]+++</p>
</li>
<li>Try finding a value for <code>b</code> that will return <code>1</code> if <code>a</code> is the atom <code>42</code>:
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(42 [3 b])
</pre></div></div>
<p>Not only is this possible, but you already know the formula to do it.<span class="intersentencespace"></span></p>
</li></ol></div></div>
<div id="sec-nock_4" data-tralics-id="cid7" class="section" data-number="3.4"><h2><a href="ch1_intro_to_nock_fragment.html#sec-nock_4" class="heading hyperref"><span class="number">3.4 </span>Nock 4</a></h2>
<p>Last section we learned how to test whether a noun is an atom or a cell with
<code>Nock 3</code>.<span class="intersentencespace"></span> Now we’re going to figure out what <code>Nock 4</code> does.</p>
<p>Let’s start playing with <code>Nock 4</code>, using <code>[[44 45] 46]</code> as our subject:
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([[44 45] 46] [4 0])
! exit

~tomsyt-balsen/try=&gt; .*([[44 45] 46] [4 1])
! exit

~tomsyt-balsen/try=&gt; .*([[44 45] 46] [4 2])
! exit
</pre></div></div>
<p>Okay, this is starting to feel a lot like <code>Nock 3</code>.<span class="intersentencespace"></span> Looks like <code>Nock 4</code> doesn’t
like atoms either.<span class="intersentencespace"></span> Remember that <code>Nock 3</code> took a cell that was a formula as its
argument:
</p><div class="code"><div class="highlight"><pre>*[subject [3 formula]]
</pre></div></div>
<p>And then depending on what the expression
</p><div class="code"><div class="highlight"><pre>*[subject formula]
</pre></div></div>
<p>produced, <code>Nock 3</code> would return a <code>0</code> or <code>1</code>, according to the function <code>?(x)</code>
that we defined:
</p><div class="code"><div class="highlight"><pre>*[a [3 b]]         ?(*[a b])
?(cell)            0
?(atom)            1
</pre></div></div>
<p>Let’s assume that Nock 4 operates in a similar way.<span class="intersentencespace"></span> Let’s use the formula <code>[0
n]</code> to try to apply Nock 4 to different axes in our subject:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([[44 45] 46] [4 [0 1]])
! exit

~tomsyt-balsen/try=&gt; .*([[44 45] 46] [4 [0 2]])
! exit

~tomsyt-balsen/try=&gt; .*([[44 45] 46] [4 [0 3]])
47
</pre></div></div>
<p>Well!<span class="intersentencespace"></span> That’s blessedly simple then.<span class="intersentencespace"></span> Watch:
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([[44 45] 46] [0 3])
46

~tomsyt-balsen/try=&gt; .*([[44 45] 46] [4 [0 3]])
47
</pre></div></div>
<p>Can you guess what
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([[44 45] 46] [4 [0 4]])
</pre></div></div>
<p>would produce?</p>
<p>If you said
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([[44 45] 46] [4 [0 4]])
45
</pre></div></div>
<p>then you’re starting to get the hang of this.<span class="intersentencespace"></span> +++recall from section … that … represents <code>/4</code>, which in the case of <code>[[44 45] 46]</code> is just <code>44</code>.<span class="intersentencespace"></span> Applying <code>Nock 4</code> to this yields <code>45</code>.+++</p>
<p>Yes, ladies and gentlemen, <code>Nock
4</code> is increment.<span class="intersentencespace"></span> Nock together your subject and the formula in your argument,
and whatever that produces, add 1 to it.</p>
<p>But what if <code>*[subject formula]</code> produces a cell instead of an atom?<span class="intersentencespace"></span> How do we
add <code>1</code> to a cell?<span class="intersentencespace"></span> Simple—we don’t.<span class="intersentencespace"></span> The Sun continues to rise in the east,
pigs remain regretfully earthbound, Hell is still rather toasty, and
incrementing a cell in Nock produces an ! exit:
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([[44 45] 46] [4 [0 2]])
! exit
</pre></div></div>
<p>Assuming we understood how <code>Nock 3</code> worked, writing down our pattern for <code>Nock 4</code> is easy:</p>
<p>Nock 3:
</p><div class="code"><div class="highlight"><pre>*[a [3 b]]         ?(*[a b])
?(cell)            0
?(atom)            1
</pre></div></div>
<p>Nock 4:
</p><div class="code"><div class="highlight"><pre>*[a [4 b]]         +(*[a b])
+(cell)            ! exit
+(atom)            1 + atom
</pre></div></div>
<p><code>+(x)</code> is, again, just some notation so we can write out both branches of Nock
4.</p>
<p>An interesting property of Nock 4 is that we can chain it together to
increment successive times.<span class="intersentencespace"></span> </p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(44 [4 [0 1]])
45

~tomsyt-balsen/try=&gt; .*(44 [4 [4 [0 4]]])
46

~tomsyt-balsen/try=&gt; .*(44 [4 [4 [4 [0 4]]]])
47

~tomsyt-balsen/try=&gt; .*(44 [4 [4 [4 [4 [0 4]]]]])
48

~tomsyt-balsen/try=&gt; .*(44 [4 [4 [4 [4 [4 [0 4]]]]]])
49
</pre></div></div>
<p>Those brackets are starting to really pile up.<span class="intersentencespace"></span> Which is making this whole
process a lot less legible than we would like.</p>
<p>Fortunatley Nock has a notational rule that’ll let us not have to write so many
of those brackets.<span class="intersentencespace"></span> </p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(44 [4 [4 [4 [4 [4 [0 4]]]]]])
49

~tomsyt-balsen/try=&gt; .*(44 [4 4 4 4 4 0 4])
49
</pre></div></div>
<p>Woah.<span class="intersentencespace"></span> That’s a lot cleaner.</p>
<p>Concisely, Nock considers brackets to group to the right.<span class="intersentencespace"></span> If you’ll recall from back in <a href="ch1_intro_to_nock_fragment.html#sec-getting_started_summary" class="hyperref">Section <span class="ref">3.1.1</span></a>:
</p><div class="code"><div class="highlight"><pre>A noun is an atom or a cell.
An atom is a natural number.
A cell is an ordered pair of two nouns.
</pre></div></div>
<p>Which means that formally, all nouns in Nock are either singletons (atoms) or
cells (pairs).<span class="intersentencespace"></span> There are no triples, quadruples, or <span class="inline_math">\( n \)</span>-<a href="https://en.wikipedia.org/wiki/Tuple">tuples</a>:
</p><div class="code"><div class="highlight"><pre>[a b c]
[a b c d]
[a b c d e]
</pre></div></div>
<p>etc.</p>
<p>Although a triple like <code>[a b c]</code> doesn’t exist in Nock, it is easier on the
eyes, so we can map a nested pair onto it:
</p><div class="code"><div class="highlight"><pre>[a b c]         [a [b c]]
</pre></div></div>
<p>Which means that the Nock interpreter, whenever it sees a triple (or any
<span class="inline_math">\( n \)</span>-tuple, for <span class="inline_math">\( n&gt;2 \)</span>), just inserts the needed brackets.</p>
<p>Let’s do some more examples to help you get the hang of it:
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(44 [4 [4 [4 [4 [4 0 1]]]]])
49

~tomsyt-balsen/try=&gt; .*(44 [4 [4 [4 [4 4 0 1]]]])
49

~tomsyt-balsen/try=&gt; .*(44 [4 [4 [4 4 4 0 1]]])
49

~tomsyt-balsen/try=&gt; .*(44 [4 [4 4 4 4 0 1]])
49

~tomsyt-balsen/try=&gt; .*(44 [4 4 4 4 4 0 1])
49
</pre></div></div>
<p>We can’t get rid of the last pair, though:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(44 4 4 4 4 4 0 1)
~ &lt;syntax error at [1 18]&gt;
</pre></div></div>
<p>This is just an artifact of Arvo’s Nock interpreter, which we directly access
with the <code>.*</code> function (pronounced <code>dottar</code>, a contraction of “dot-star”).<span class="intersentencespace"></span> <code>.*</code> takes two
arguments, a subject and a formula:
</p><div class="code"><div class="highlight"><pre>.*(subject [formula])
</pre></div></div>
<p>And for inscrutable reasons +++recast this; what are the actual reasons, if any?+++, the formula has to be in brackets.<span class="intersentencespace"></span> As does the
subject, if it’s a cell:
</p><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(44 45 [4 4 4 4 4 0 2])
~ &lt;syntax error at [1 9]&gt;

~tomsyt-balsen/try=&gt; .*([44 45] [4 4 4 4 4 0 2])
49
</pre></div></div>
<div id="uid23" data-tralics-id="uid23" class="subsection" data-number="3.4.1"><h3><a href="ch1_intro_to_nock_fragment.html#uid23" class="heading hyperref"><span class="number">3.4.1 </span>Summary</a></h3>
<p>Let’s review:</p>
<p><strong>Nock 4:</strong>
</p><div class="code"><div class="highlight"><pre>*[a [4 b]]         +(*[a b])
+(cell)            ! exit
+(atom)            1 + atom
</pre></div></div>
<p><strong>Brackets:</strong></p>
<p>Brackets group to the right.<span class="intersentencespace"></span> </p><div class="code"><div class="highlight"><pre>[a b c]         [a [b c]]
</pre></div></div>
<p><strong>Nock interpreter:</strong></p>
<p><code>.*</code> is pronounced “dottar”</p>
<p>Takes two arguments, subject and formula:
</p><div class="code"><div class="highlight"><pre>.*(subject [formula])
</pre></div></div>
<p>formula must be bracketed.</p>
</div>
<div id="uid24" data-tralics-id="uid24" class="subsection" data-number="3.4.2"><h3><a href="ch1_intro_to_nock_fragment.html#uid24" class="heading hyperref"><span class="number">3.4.2 </span>Exercises</a></h3>
<ol><li>Chain together Nock 4 and Nock 3, so that cells produce 2 and atoms produce 3.<span class="intersentencespace"></span>
</li>
<li>Write a formula that always returns the cell [4 0 1].<span class="intersentencespace"></span>
</li></ol></div></div>
<div id="sec-nock_5_nock_2" data-tralics-id="cid8" class="section" data-number="3.5"><h2><a href="ch1_intro_to_nock_fragment.html#sec-nock_5_nock_2" class="heading hyperref"><span class="number">3.5 </span>Nock 5, Nock 2 and Formula Distribution</a></h2>
<p>So we’ve learned how to do some simple operations with Nock.<span class="intersentencespace"></span> Now we’re going to get a little fancier.</p>
<p>To jog your memory, we’ve seen the following operators so far: +++start adding massive repetition of what each <code>Nock n</code> is.+++</p>
<div class="codelisting" id="code-nock_review" data-tralics-id="uid27" data-number="3.2"><div class="heading"><span class="number">Listing 3.2:</span> 

<span class="description">A review of Nock 0, 1, 3, and 4.</span>
</div>

<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; :: Nock 0: Tree address
~tomsyt-balsen/try=&gt; :: *[a [0 b]]               /b of a
~tomsyt-balsen/try=&gt;
<span class="hll">~tomsyt-balsen/try=&gt;   .*([42 43] [0 1])
</span><span class="hll">[42 43]
</span>
~tomsyt-balsen/try=&gt; :: Nock 1: The constant operator
~tomsyt-balsen/try=&gt; :: *[a [1 b]]               b for every a
~tomsyt-balsen/try=&gt;
<span class="hll">~tomsyt-balsen/try=&gt;   .*([42 43] [1 0])
</span><span class="hll">[42 43]
</span>
~tomsyt-balsen/try=&gt; :: Nock 3: The cell tester
~tomsyt-balsen/try=&gt; :: ?(cell)            0 ("yes")
~tomsyt-balsen/try=&gt; :: ?(atom)            1 ("no")
~tomsyt-balsen/try=&gt; :: *[a [3 b]]         ?(*[a b])
~tomsyt-balsen/try=&gt;
<span class="hll">~tomsyt-balsen/try=&gt;   .*([42 43] [3 0 1])
</span><span class="hll">0
</span>
~tomsyt-balsen/try=&gt; :: Nock 4: Increment
~tomsyt-balsen/try=&gt; :: +(cell)            ! exit
~tomsyt-balsen/try=&gt; :: +(atom)            1 + atom
~tomsyt-balsen/try=&gt; :: *[a [4 b]]         +(*[a b])
<span class="hll">~tomsyt-balsen/try=&gt;   .*([42 43] [4 0 2])
</span><span class="hll">43
</span></pre></div></div></div><p>These all have the pattern shown in <a href="ch1_intro_to_nock_fragment.html#code-formula_pattern" class="hyperref">Listing <span class="ref">3.3</span></a>, where the operator is one of four atoms (0, 1, 3 or 4).</p>
<div class="codelisting" id="code-formula_pattern" data-tralics-id="uid28" data-number="3.3"><div class="heading"><span class="number">Listing 3.3</span> 

<span class="description"></span>
</div>

<div class="code"><div class="highlight"><pre>*[subject [operator arguments]]
</pre></div></div></div><p>What if we replaced that atom with a cell?<span class="intersentencespace"></span> For example, in</p>
<div class="code"><div class="highlight"><pre>.*([42 43] [3 0 1])
</pre></div></div>
<p>let’s see what happens if we replace the atom <code>3</code> with the cell <code>[0 1]</code>:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 43] [[0 1] 0 1])
[[42 43] 42 43]
</pre></div></div>
<p>If we recall the <code>Nock 0</code> example from <a href="ch1_intro_to_nock_fragment.html#code-nock_review" class="hyperref">Listing <span class="ref">3.2</span></a>,</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 43] [0 1])
[42 43]
</pre></div></div>
<p>we see that <code>.*([[42 43] 42 43])</code> is just a nested combination of the result of the formula <code>.*([42 43] [0 1])</code>.<span class="intersentencespace"></span> In other words, it appears that Arvo is applying each operator in <code>[[0 1] 0 1]</code> to the argument <code>[42 43]</code> and combining the results.</p>
<p>Let’s try some other formulas to see if this pattern holds (<a href="ch1_intro_to_nock_fragment.html#code-other_nested_formulas" class="hyperref">Listing <span class="ref">3.4</span></a>).</p>
<div class="codelisting" id="code-other_nested_formulas" data-tralics-id="uid29" data-number="3.4"><div class="heading"><span class="number">Listing 3.4:</span> 

<span class="description">Applying a series of nested formulas to the same argument.</span>
</div>

<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 43] [[0 2] 0 1])
[42 42 43]

~tomsyt-balsen/try=&gt; .*([42 43] [[0 2] 0 2])
[42 42]

~tomsyt-balsen/try=&gt; .*([42 43] [[0 1] 0 2])
[[42 43] 42]
</pre></div></div></div><p>Recalling from <a href="ch1_intro_to_nock_fragment.html#code-several_nock_formulas" class="hyperref">Listing <span class="ref">3.1</span></a> that</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 43] [0 2])
42
</pre></div></div>
<p>we see that the pattern we guessed continues to hold: Arvo is running both formulas and then just combining the results in a cell.</p>
<p>+++For the example below, we should establish the values of <code>.*([42 43] [3 0 2])</code> and <code>.*([42 43] [4 0 3])</code>+++</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 43] [[3 0 1] 3 0 2])
[0 1]

~tomsyt-balsen/try=&gt; .*([42 43] [[3 0 1] 4 0 3])
[0 44]

~tomsyt-balsen/try=&gt; .*([42 43] [[1 [0 1]] 4 0 3])
[[0 1] 44]

~tomsyt-balsen/try=&gt; .*([42 43] [[4 0 3] 1 [0 1]])
[44 [0 1]]
</pre></div></div>
<p>Yup, the subject is definitely running through both formulas in parallel.<span class="intersentencespace"></span> The
last example seems to do something like this +++it doesn’t match the example+++:</p>
<div class="code"><div class="highlight"><pre>*[[42 43] [4 0 3] 1 [55 73]]         [*[[42 43] [4 0 3]] *[[42 43] 1 [55 73]]]
</pre></div></div>
<p>which we can evaluate using Arvo:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 43] [4 0 3])
44

~tomsyt-balsen/try=&gt; .*([42 43] [1 [0 1]])
[0 1]
</pre></div></div>
<p>Or by hand, which is good practice.<span class="intersentencespace"></span> Open up a blank text file or grab a pen and
copy along:</p>
<div class="code"><div class="highlight"><pre>*[[42 43] [4 0 3] 1 [0 1]]  [*[[42 43] [4 0 3]] *[[42 43] 1 [0 1]]]

&lt;&lt;  Nock 4:       *[a [4 b]]          +(*[a b]) &gt;&gt;

[+(*[[42 43] 0 3]]) *[[42 43] 1 [0 1]]]

&lt;&lt;  Nock 0:       *[a [0 b]]          /b of a  &gt;&gt;

[+(43) *[[42 43] 1 [0 1]]]

&lt;&lt;     +():       +(atom)             1 + atom  &gt;&gt;

[44 *[[42 43] 1 [0 1]]]

&lt;&lt;  Nock 1:       *[a [1 b]]          b  &gt;&gt;

[44 [0 1]]
</pre></div></div>
<p>Thus,</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 43] [[4 0 3] 1 [0 1]])
[44 [0 1]]
</pre></div></div>
<p>We could write the first line of the reduction more generally as</p>
<div class="code"><div class="highlight"><pre>*[subject [formula1] formula2]     [*[subject formula1] *[subject formula2]]
</pre></div></div>
<p>This is a little long for my taste, but since a formula is a cell we can
rewrite it as in <a href="ch1_intro_to_nock_fragment.html#code-further_reduction" class="hyperref">Listing <span class="ref">3.5</span></a>, where <code>a</code> is the subject, <code>[b c]</code> is <code>formula1</code> and <code>[d e]</code> is <code>formula2</code>.</p>
<div class="codelisting" id="code-further_reduction" data-tralics-id="uid30" data-number="3.5"><div class="heading"><span class="number">Listing 3.5</span> 

<span class="description"></span>
</div>

<div class="code"><div class="highlight"><pre>*[a [b c] d e]     [*[a b c] *[a d e]]
</pre></div></div></div><p>Recalling the common pattern</p>
<div class="code"><div class="highlight"><pre>*[subject [operator arguments]]
</pre></div></div>
<p>from <a href="ch1_intro_to_nock_fragment.html#code-formula_pattern" class="hyperref">Listing <span class="ref">3.3</span></a>, we see that in <code>*[a d]</code> the value of <code>d</code> must be a cell of the form <code>[operator arguments]</code>.<span class="intersentencespace"></span> This means that in <a href="ch1_intro_to_nock_fragment.html#code-further_reduction" class="hyperref">Listing <span class="ref">3.5</span></a> we can relabel the cell <code>d e</code> (where <code>d</code> might be an atom) to just <code>d</code> (where now <code>d</code> has to be a cell), which yields <a href="ch1_intro_to_nock_fragment.html#code-final_reduction" class="hyperref">Listing <span class="ref">3.6</span></a>.</p>
<div class="codelisting" id="code-final_reduction" data-tralics-id="uid31" data-number="3.6"><div class="heading"><span class="number">Listing 3.6</span> 

<span class="description"></span>
</div>

<div class="code"><div class="highlight"><pre>*[a [b c] d]     [*[a b c] *[a d]]
</pre></div></div></div><p>What’s really cool about the rule in <a href="ch1_intro_to_nock_fragment.html#code-final_reduction" class="hyperref">Listing <span class="ref">3.6</span></a> that, like the operators, it also chains +++This does not appear to be of the form <code>*[a [b c] d]</code>+++:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 [46 47]] [[0 1] [3 0 1] [0 2]])
[[42 46 47] 0 42]
</pre></div></div>
<p>So if we wanted to produce our subject with all the atoms incremented, we could
do that:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 [46 47]] [[4 0 1] [4 0 2] [4 0 3]])
[43 47 48]
</pre></div></div>
<p>We can make our chains as long as we like</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 [46 47]] [[0 1] [3 0 1] [0 2] [3 0 2] [0 3]])
[[42 46 47] 0 42 1 [46 47] 0]
</pre></div></div>
<p>That is, we can evaluate arbitrary numbers of formulas on the same subject in
parallel.</p>
<p>But what if we want to run them in series?</p>
<p>The expression <code>*[[42 43] [[4 0 3] 1 [0 1]]]</code> is a good example of how this might work +++Make explicit in what sense this is evaluation in “series”+++:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 43] [[4 0 3] 1 [3 0 1]])
[44 [3 0 1]]
</pre></div></div>
<p>Wouldn’t it be interesting if we could run <code>[44 [3 0 1]]</code> through Nock again and end up with <code>*[44 [3 0 1]]</code> or just <code>1</code>?<span class="intersentencespace"></span> +++Why would this be interesting?+++</p>
<p>We’d need a recursive operator to do that +++why?+++.<span class="intersentencespace"></span> Fortunately, we’ve got one, Nock 2 +++this is the first explicit mention of Nock 2,and the example is rather complicated+++:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 43] [2 [4 0 3] 1 [3 0 1]])
1
</pre></div></div>
<p>Obviously, this is a toy example because we could just do the same thing
functionally with +++this is not obvious<span class="unicode">—</span>so far as I can tell, this is the first time that the second cell in a formula has been of length 4+++:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 43] [3 4 0 3])
1
</pre></div></div>
<p>But Nock 2 also lets us call a formula inside our subject.<span class="intersentencespace"></span> +++I’m completely confused at this point+++</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([[40 43] [4 0 1]] [2 [0 4] [0 3]])
41

~tomsyt-balsen/try=&gt; .*([[40 43] [4 0 1]] [2 [0 5] [0 3]])
44
</pre></div></div>
<p>Or we could completely separate the operator and arguments: +++Whaa?+++</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([[40 43] [0 1 3 4]] [2 [0 2] [0 31] [0 6] [0 30]])
44
</pre></div></div>
<p>We did a lot of slicing and dicing of nouns with the formula distribution rule.<span class="intersentencespace"></span> Nock 2 lets us run those reassembled nouns as expressions.<span class="intersentencespace"></span> We could think of
Nock 2 as being exactly like the distribution rule:</p>
<div class="code"><div class="highlight"><pre>*[a [b c] d]          [*[a b c] *[a d]]
</pre></div></div>
<p>except that Nock 2 has an extra <code>*</code>, meaning we run everything through Nock a
second time.<span class="intersentencespace"></span> So if we have two formulas</p>
<div class="code"><div class="highlight"><pre>*[subject 2 formula1 formula2]      *[*[subject formula1] *[subject formula2]]
</pre></div></div>
<p>which we can rewrite as:</p>
<div class="code"><div class="highlight"><pre>*[a 2 b c]            *[*[a b] *[a c]]
</pre></div></div>
<p>Let’s work through that last example again:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([[40 43] [0 1 3 4]] [2 [0 2] [0 31] [0 6] [0 30]])
44
</pre></div></div>
<p>So we’ve got our subject <code>[[40 43] [0 1 3 4]]</code> and four different formulas:
<code>[0 2] [0 31] [0 6] [0 30]</code></p>
<p>Let’s apply each of these to our subject separately:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([[40 43] [0 1 3 4]] [0 2])
[40 43]

~tomsyt-balsen/try=&gt; .*([[40 43] [0 1 3 4]] [0 31])
4

~tomsyt-balsen/try=&gt; .*([[40 43] [0 1 3 4]] [0 6])
0

~tomsyt-balsen/try=&gt; .*([[40 43] [0 1 3 4]] [0 30])
3
</pre></div></div>
<p>If instead of Nock 2, we had just used the formula distribution rule:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([[40 43] [0 1 3 4]] [[0 2] [0 31] [0 6] [0 30]])
[[40 43] 4 0 3]
</pre></div></div>
<p>But since Nock 2 is recursive:</p>
<div class="code"><div class="highlight"><pre>*[[[40 43] [0 1 3 4]] [2 [0 2] [0 31] [0 6] [0 30]]]
</pre></div></div>
<p>reduces to:</p>
<div class="code"><div class="highlight"><pre>*[[40 43] 4 0 3]
</pre></div></div>
<p>which is, of course, <span class="inline_math">\( 43 + 1 \)</span>, or <span class="inline_math">\( 44 \)</span>.</p>
<p>Now that we understand how to slice up nouns in our subject, let’s introduce Nock 5.</p>
<p>Nock 5 is exactly like Nock 3 and Nock 4 in structure, but we’ve saved it for
last because it’s easier to understand how to use it after you know how to
distribute formulas.<span class="intersentencespace"></span> See if you can figure it out from the following:</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([42 42] [5 [0 2] [0 3]])
0

~tomsyt-balsen/try=&gt; .*([42 43] [5 [0 2] [0 3]])
1

~tomsyt-balsen/try=&gt; .*([42 44] [5 [0 2] [0 3]])
1

~tomsyt-balsen/try=&gt; .*([[42 42] [42 42]] [5 [0 2] [0 3]])
0

~tomsyt-balsen/try=&gt; .*([[42 43] [42 43]] [5 [0 2] [0 3]])
0

~tomsyt-balsen/try=&gt; .*([[42 43] [42 43]] [5 [0 4] [0 3]])
1

~tomsyt-balsen/try=&gt; .*([[42 42] [42 42]] [5 [0 2] [0 3]])
0
</pre></div></div>
<p>Yes, Nock 5 is an equality test +++Instead of saying ‘Yes’, work through it in more detail+++:</p>
<div class="code"><div class="highlight"><pre>*[a 5 b]
</pre></div></div>
<p>If the head and the tail of the cell produced by <code>*[a b]</code> are the same, then
Nock 5 produces 0, if they are different, Nock 5 produces 1:</p>
<div class="code"><div class="highlight"><pre>*[a 5 b]              =(*[a b])
=([a a])              0
=([a !a])              1
</pre></div></div>
<p>Where <code>!a</code> just means “not a.”</p>
<p>But what if <code>*[a b]</code> inside <code>=(*[a b])</code> produces an atom?</p>
<div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*([[42 42] [42 42]] [5 [1 1]])
! exit
</pre></div></div>
<p>So we need to add</p>
<div class="code"><div class="highlight"><pre>=(atom)              ! exit
</pre></div></div>
<p>to our rule.</p>
<p>Let’s reduce the last example from above by hand:</p>
<div class="code"><div class="highlight"><pre>*[[[42 42] [42 42]] [5 [0 2] [0 3]]]

    *[a 5 b]                =(*[a b])

=(*[[[42 42] [42 42]] [0 2] [0 3]])

    *[a [b c] d]            [*[a b c] *[a d]]

=([*[[[42 42] [42 42]] [0 2]] *[[[42 42] [42 42]] [0 3]]])

    *[a [0 b]]               /b of a

=([[42 42] *[[[42 42] [42 42]] [0 3]]])

    *[a [0 b]]               /b of a

=([[42 42] [42 42]])

    =([a a])                 0

1
</pre></div></div>
<div id="uid32" data-tralics-id="uid32" class="subsection" data-number="3.5.1"><h3><a href="ch1_intro_to_nock_fragment.html#uid32" class="heading hyperref"><span class="number">3.5.1 </span>Summary</a></h3>
<p><strong>Formula Distribution:</strong></p>
<p>A formula with a second formula at its head instead of an operator distributes the subject over both formulas:
</p><div class="code"><div class="highlight"><pre>*[a [b c] d]          [*[a b c] *[a d]]
</pre></div></div>
<p><code>[b c]</code> is the first formula, d is the second formula.</p>
<p><strong>Nock 2</strong></p>
<div class="code"><div class="highlight"><pre>*[subject 2 formula-a formula]               *[*[subject formula1] *[subject formula2]]
</pre></div></div>
<p>which translates to</p>
<div class="code"><div class="highlight"><pre>*[a 2 b c]            *[*[a b] *[a c]]
</pre></div></div>
<p><strong>Nock 5</strong>
</p><div class="code"><div class="highlight"><pre>*[a 5 b]              =(*[a b])
=([a a])              0
=([a !a])              1
=(atom)               ! exit
</pre></div></div>
</div>
<div id="uid33" data-tralics-id="uid33" class="subsection" data-number="3.5.2"><h3><a href="ch1_intro_to_nock_fragment.html#uid33" class="heading hyperref"><span class="number">3.5.2 </span>Exercises</a></h3>
<ol><li>Using the above rule, write a formula that reverses the order of the atoms in <code>[42 46 [68 69] 55]</code> (i.e., <code>[55 [68 69] 46 42]</code>).<span class="intersentencespace"></span>
</li>
<li>Put the subject <code>[4 3 7 2 5 1 6]</code> in order from least to greatest.<span class="intersentencespace"></span>
</li>
<li>Does <code>*[[42 42] 5 [0 1] [0 3]]</code> produce a <code>yes</code> or a <code>no</code>?<span class="intersentencespace"></span>
</li>
<li>Write a noun that contains some data (nouns you find interesting) and some code (formulas you find interesting), write an expression with that noun as the subject that produces a single data-noun and a single code cell.<span class="intersentencespace"></span> Then use Nock 2 to apply the formula to the data.<span class="intersentencespace"></span>
</li>
<li>Choose a subject such that the following expression evaluates
</li></ol><div class="code"><div class="highlight"><pre>~tomsyt-balsen/try=&gt; .*(subject [2 [0 5] [0 4] [0 3]])
43
</pre></div></div>
</div></div>
<div id="cid9" data-tralics-id="cid9" class="section" data-number="3.6"><h2><a href="ch1_intro_to_nock_fragment.html#cid9" class="heading hyperref"><span class="number">3.6 </span>Section VI: Conclusion</a></h2>
<p>Let’s list out all the rules we’ve learned so far, with the explanations collapsed:</p>
<div class="code"><div class="highlight"><pre>A noun is an atom or a cell.
An atom is a natural number.
A cell is an ordered pair of nouns.


[a b c]              [a [b c]]

?(cell)               0
?(atom)               1
+(cell)               ! exit
+(atom)               1 + atom
=([a a])              0
=([a !a])              1
=(atom)               ! exit


*[a 0 b]              /b of a
*[a 1 b]              b
*[a 2 b c]            *[*[a b] *[a c]]
*[a 3 b]              ?(*[a b])
*[a 4 b]              +(*[a b])
*[a 5 b]              =(*[a b])

*[a [b c] d]          [*[a b c] *[a d]]
</pre></div></div>
<p>That looks cleaner.<span class="intersentencespace"></span> Now let’s look at an abridged version of the real Nock spec, which you should now be able to mostly read</p>
<div class="code"><div class="highlight"><pre>1  ::    A noun is an atom or a cell.
2  ::    An atom is a natural number.
3  ::    A cell is an ordered pair of nouns.
4  ::
5  ::    nock(a)          *a
6  ::    [a b c]          [a [b c]]
7  ::
8  ::    ?[a b]           0
9  ::    ?a               1
10 ::    +[a b]           +[a b]
11 ::    +a               1 + a
12 ::    =[a a]           0
13 ::    =[a b]           1
14 ::    =a               =a
15 ::
16 ::    /[1 a]           a
17 ::    /[2 a b]         a
18 ::    /[3 a b]         b
19 ::    /[(a + a) b]     /[2 /[a b]]
20 ::    /[(a + a + 1) b] /[3 /[a b]]
21 ::    /a               /a
22 ::
23 ::    *[a [b c] d]     [*[a b c] *[a d]]
24 ::
25 ::    *[a 0 b]         /[b a]
26 ::    *[a 1 b]         b
27 ::    *[a 2 b c]       *[*[a b] *[a c]]
28 ::    *[a 3 b]         ?*[a b]
29 ::    *[a 4 b]         +*[a b]
30 ::    *[a 5 b]         =*[a b]
31 ::
...
38 ::
39 ::    *a               *a
</pre></div></div>
<p>Since the Nock spec has been designed to be as concise as possible, a couple things are notationally different from the rules we’ve learned.</p>
<p>The largest difference is the block that defines what the <code>/</code> or axis operator does:</p>
<div class="code"><div class="highlight"><pre>16 ::    /[1 a]           a
17 ::    /[2 a b]         a
18 ::    /[3 a b]         b
19 ::    /[(a + a) b]     /[2 /[a b]]
20 ::    /[(a + a + 1) b] /[3 /[a b]]
</pre></div></div>
<p>This block of pseudocode is functionally equivalent to saying:</p>
<p>The head of axis /n is /(2n) and the tail of axis /n is /(2n+1).</p>
<p>If you read and understood <a href="ch1_intro_to_nock_fragment.html#sec-noun_structure" class="hyperref">Section <span class="ref">3.2</span></a>, you understand what this is doing, even if you can’t parse its recursive structure.</p>
<p>The next most obvious difference is that between</p>
<div class="code"><div class="highlight"><pre>8  ::    ?[a b]           0
9  ::    ?a               1
10 ::    +[a b]           +[a b]
11 ::    +a               1 + a
12 ::    =[a a]           0
13 ::    =[a b]           1
14 ::    =a               =a
</pre></div></div>
<p>and</p>
<div class="code"><div class="highlight"><pre>?(cell)               0
?(atom)               1
+(cell)               ! exit
+(atom)               1 + atom
=([a a])              0
=([a !a])             1
=(atom)               ! exit
</pre></div></div>
<p>We’ll work through the evolution of this block:</p>
<p>First thing is that since we’re trying to make the Nock specification small, we can get rid of the parentheses:</p>
<div class="code"><div class="highlight"><pre>?cell               0
?atom               1
+cell               ! exit
+atom               1 + atom
=[a a]              0
=[a !a]             1
=atom               ! exit
</pre></div></div>
<p>Then we can remove the words ‘cell’ and ‘atom.’<span class="intersentencespace"></span> Since the rules in the nock spec match top to bottom, we can specify matching a rule to a cells or atom by putting [a b] above a.<span class="intersentencespace"></span> A cell will match [a b] and and atom will not, therefore because all cells will match [a b],
only atoms will match a below [a b].</p>
<div class="code"><div class="highlight"><pre>?[a b]             0
?a                 1
+[a b]             ! exit
+a                 1 + atom
=[a a]             0
=[a !a]            1
=a                 ! exit
</pre></div></div>
<p>Next little thing we can do, along the same principle, is change !a to b, because [a b] below [a a] will only match to a pair of unequal nouns.</p>
<div class="code"><div class="highlight"><pre>?[a b]             0
?a                 1
+[a b]             ! exit
+a                 1 + atom
=[a a]             0
=[a !a]            1
=a                 ! exit
</pre></div></div>
<p>Then there’s these lines, which we call our crash defaults:</p>
<div class="code"><div class="highlight"><pre>10 ::    +[a b]           +[a b]
14 ::    =a               =a
21 ::    /a               /a
39 ::    *a               *a
</pre></div></div>
<p>Basically the crash defaults determine when Nock needs to return an !<span class="intersentencespace"></span> exit, because something is nonsensical.<span class="intersentencespace"></span> In theory these lines imply that Nock spins forever in an infinite loop, in practice, Nock will just crash.</p>
<div class="code"><div class="highlight"><pre>10 ::    +[a b]           +[a b]
</pre></div></div>
<p>means that Nock crashes if you try to increment a cell</p>
<div class="code"><div class="highlight"><pre>14 ::    =a               =a
</pre></div></div>
<p>means that Nock crashes if you try run an equality test on an atom</p>
<div class="code"><div class="highlight"><pre>   21 ::    /a               /a
</pre></div></div>
<p>means that Nock crashes if you try to reference a noun axis that doesn’t exist</p>
<div class="code"><div class="highlight"><pre>39 ::    *a               *a
</pre></div></div>
<p>means that if you try to run something that’s not a valid formula (i.e.<span class="intersentencespace"></span> doesn’t match any of the preceding lines 1 through 38) through Nock, you guessed it, Nock crashes.</p>
<p>Replacing !<span class="intersentencespace"></span> exit in our rules with the appropriate crash default, we get the canoncial Nock specification:</p>
<div class="code"><div class="highlight"><pre>1  ::    A noun is an atom or a cell.
2  ::    An atom is a natural number.
3  ::    A cell is an ordered pair of nouns.
4  ::
5  ::    nock(a)          *a
6  ::    [a b c]          [a [b c]]
7  ::
8  ::    ?[a b]           0
9  ::    ?a               1
10 ::    +[a b]           +[a b]
11 ::    +a               1 + a
12 ::    =[a a]           0
13 ::    =[a b]           1
14 ::    =a               =a
15 ::
16 ::    /[1 a]           a
17 ::    /[2 a b]         a
18 ::    /[3 a b]         b
19 ::    /[(a + a) b]     /[2 /[a b]]
20 ::    /[(a + a + 1) b] /[3 /[a b]]
21 ::    /a               /a
22 ::
23 ::    *[a [b c] d]     [*[a b c] *[a d]]
24 ::
25 ::    *[a 0 b]         /[b a]
26 ::    *[a 1 b]         b
27 ::    *[a 2 b c]       *[*[a b] *[a c]]
28 ::    *[a 3 b]         ?*[a b]
29 ::    *[a 4 b]         +*[a b]
30 ::    *[a 5 b]         =*[a b]
31 ::
...
38 ::
39 ::    *a               *a
</pre></div></div>
<p>And that’s it!<span class="intersentencespace"></span> That’s really all there is to Nock.<span class="intersentencespace"></span> Everything else in Urbit, including the elided lines 32 through 38, is just a structure built on top of Nock.<span class="intersentencespace"></span> All your playing around in Urbit reduces to some combination of what you now already know.</p>
</div>
    </div>
  </body>
</html>
