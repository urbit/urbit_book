<div id="cid1" data-tralics-id="cid1" class="chapter" data-number="1" data-chapter="preface"><h1><a href="preface_fragment.html#cid1" class="heading hyperref"><span class="number">Chapter 1 </span>Preface: Urbit</a></h1>
<blockquote class="quotation"><p class="noindent">A complex system that works is invariably found to have evolved from a
simple system that worked.<span class="intersentencespace"></span> The inverse proposition also appears to be true:
A complex system designed from scratch never works and cannot be made to
work.<span class="intersentencespace"></span> You have to start over, beginning with a working simple system.<span class="intersentencespace"></span></p>
<p style="margin-top: 6.0pt"><span class="break"></span>
Gall’s Law</p>
</blockquote><p>Urbit is a general-purpose programming environment designed to execute a purely
functional network operating system and a referentially transparent network
address space.</p>
<p>Urbit consists of four conceptual levels:</p>
<p>At the lowest-level, Urbit reduces to Nock, a stateless virtual machine based
on combinatory logic and defined in 340 bytes.<span class="intersentencespace"></span> The Nock machine is sealed -
all execution is “pure.”<span class="intersentencespace"></span> Nock’s goal is extreme commoditization of computing
semantics.</p>
<p>Nock acts as our functional equivalent of assembly language.<span class="intersentencespace"></span> Nock is differs
from assembly language in that it<span class="unicode">’</span>s interpreted, rather than directly executed
by the hardware.<span class="intersentencespace"></span> It is like assembly language in that everything in Urbit
executes as Nock and most programming in Urbit will be done using higher-level
tools that reduce to Nock.</p>
<p>Hoon is a high-level language which defines itself in Nock.<span class="intersentencespace"></span> Its self-compiling
kernel, 7000 lines of code, specifies Hoon unambiguously; there is no Hoon
spec.<span class="intersentencespace"></span> Hoon can be classified as a pure, strict higher-order static
type-inferred functional language, with co/contra/bivariance and genericity.<span class="intersentencespace"></span> However, Hoon does not use lambda calculus, unification, or other constructs
from “PL theory.”</p>
<p>Hoon also excels at handling and validating untyped data, a common task on the
Internet.<span class="intersentencespace"></span> Its syntax is entirely novel and initially quite frightening a
consequence of Hoon having been designed to optimize for actual usability
rather than cosmetic friendliness.<span class="intersentencespace"></span> A frequent experience amongst Hoon
programmers is writing code that works the first time it successfully compiles.</p>
<p>Arvo is a deterministic functional operating system and network protocol,
written in 5000 lines of Hoon.<span class="intersentencespace"></span> Arvo features a revision control filesystem and
the network is a blocking global immutable namespace.<span class="intersentencespace"></span> Meaning that all data on
the network or off it can be treated as a constant.<span class="intersentencespace"></span> Additionally, Arvo
preserves a log of all the events it sees, meaning that all computation on an
Arvo instance is recorded and can be played back and examined.</p>
<p>The network blah blah blah</p>
</div>